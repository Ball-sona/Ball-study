# 위크맵과 위크셋

메모리 관리에 유용한 위크맵과 위크셋 자료구조에 대해 알아보자.

## 위크맵

위크맵은 맵과 유사하지만, 키로 사용된 객체가 가비지 컬렉터의 제거 되상이 된다면 이에 대응하는 요소를 제거하는 자료구조이다.

- 그렇기 때문에 위크맵의 **키는 반드시 객체**여야 한다.
- 위크맵의 **키로 사용된 객체가 어디에서도 참조되지 않고 있다**면, 해당 객체는 메모리와 위크맵에서 **자동으로 삭제**된다.

```js
const weakMap = new WeakMap();

let user1 = { name: 'sona' };
weakMap.set(user1, 'user');

user1 = null; // 객체 {name:'sona'}는 메모리에서 제거된다.
```

### 메서드

- 요소 추가: `set(key,value)` 메서드
- 값 반환: `get(key)` 메서드
- 요소 삭제: `delete(key)` 메서드
- 요소 존재 여부 확인: `has(key)` 메서드

위크맵은 총 4개의 메서드만 지원한다. 이는 가비지 컬렉션의 동작 방식 때문이다.

우리는 <u>가비지 컬렉션의 동작 시점을 알 수가 없다</u>. 즉 객체가 참조를 잃었을 때 가비지 컬렉션이 그 객체를 즉시 메모리에서 제거할 지, 다른 삭제 작업이 있을 때까지 대기하다가 함께 제거할 지 우리는 결코 예측할 수 없다. 따라서 위크맵의 전체 요소를 대상으로 무언가를 하는 메서드는 동작 자체가 불가능하다.

## 언제 사용될까?

### 추가 데이터

위크맵은 <u>부차적인 데이터를 저장할 곳이 필요</u>할 때 유용하게 사용된다. 위크맵의 키에는 주요 자료가 담긴 객체가 들어가고, 값에는 방문 횟수 등 부수적인 자료를 저장하게 되는 것이다.

특정 페이지에서 사용자의 방문 횟수를 카운팅하는 상황을 예로 들어보자.

```js
const visitsCountMap = new WeakMap();
function countUser(user) {
  let count = visitsCountMap.get(user) || 0;
  visitsCountMap.set(user, count + 1);
}

let user1 = { name: 'sona' };
countUser(user1);
user1 = null;
```

- 특정 사용자가 페이지에 접속할 때마다 `countUser` 함수가 실행되면서 `visitsCountMap` 이라는 위크맵에 접속 횟수를 저장한다.
- 그러다 만약 사용자가 탈퇴를 하게 되어 객체를 담고 있던 변수를 null로 덮어썼다면? 사용자 정보 객체(`{name:'sona}`)는 더이상 도달할 수 없는 상태가 되어 자동으로 메모리에서 삭제된다.
- 이는 해당 객체가 위크맵의 키로 관리되고 있었기 때문에 가능하다.

만약 위 예시에서 맵을 사용하고 있었다면? 변수 `user1` 에 null 값이 할당되어도 여전히 해당 객체(`{name:'sona}`)는 맵의 키로 사용되고 있으므로 메모리에서 삭제되지 않는다. 따라서 특정 사용자가 탈퇴하여 객체가 제거 대상이 될 때 맵 내 저장된 요소도 손수 지워주지 않는다면, 해당 맵이 차지하는 메모리 공간은 한없이 커질 것이다.

### 캐싱

동일한 함수를 여러 번 호출해야 할 때, 최초 호출 시 반환된 값을 어딘가에 저장해 두었다가 이후에는 함수를 재호출하는 대신 저장된 값을 반환하는 '캐싱(caching)' 기능을 위크맵을 사용해 구현할 수 있다.

```js
const cache = new WeakMap();
function process(obj) {
  if (!cache.has(obj)) {
    let result = calc(obj); // 연산 수행
    cache.set(obj, result);
  }
  return cache.get(obj);
}

let data = {};
const res1 = process(data); // 연산 수행 결과 반환
const res2 = process(data); // 캐시된 값 반환
data = null;
```

- `process` 함수는 호출될 때마다 <u>인수로 받은 객체를 키로 갖는 요소</u>가 `cache` 라는 위크맵 내에 있는지 확인한다.
- 만약 요소가 없다면 객체와 연산 결과를 함께 위크맵에 넣어주고, 있다면 위크맵에서 바로 값을 꺼내 반환한다. 연산을 한번만 하면 되므로 여러번 호출되는 함수를 빠르게 처리할 수 있다.
- 이후 프로세스에 인자로 넘겼던 객체가 가비지 컬렉터의 제거 대상이 되면, WeakMap 내에서 해당 객체를 키로 갖고 있던 요소도 자동으로 메모리에서 삭제된다.

위크맵이 아닌 맵을 통해 캐시를 관리했다면 객체가 제거될 때마다 수동으로 캐시를 청소해주어야 했겠지만, 위크맵은 자동으로 이를 관리해주므로 메모리 관리를 최적화할 수 있다.

## 위크셋

위크셋도 위크맵과 마찬가지로 <u>키로 갖고 있는 객체가 도달 가능할 때에만 메모리에 유지</u>한다. 위크맵과 달리 방문 유무 등 단순한 값을 확인할 때 사용된다.

```js
const visitedSet = new WeakSet();

let user1 = { name: 'sona' };
visitedSet.add(user1);
visitedSet.add(user1); // 여전히 위크셋엔 요소 1개 (중복 허용x)
user1 = null; // 객체 {name:'sona'}는 자동으로 제거됨
```

### 메서드

- 요소 추가: `add(value)` 메서드
- 요소 삭제: `delete(key)` 메서드
- 요소 존재 여부 확인: `has(key)` 메서드

위크맵과 마찬가지로 전체 요소에 접근하거나 반복 작업에 사용되는 메서드는 지원하지 않는다.
