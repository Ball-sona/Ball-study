# 연산자

자바스크립트의 여러 연산자들에 대해 알아보자.

## 덧셈 연산자 `+`

### 이항 연산자

이항 연산자 `+` 의 피연산자로 문자열이 전달되면 덧셈이 아닌 문자열을 연결(concat)한다. 두 피연산자 중 하나만 문자열이라면 다른 피연산자도 문자형으로 변환되어 문자열로 연결된다.

```js
const str1 = 'he' + 'llo'; // "hello"
const str2 = '1' + 2; // "12"
```

### 단항 연산자

숫자 앞에 단항 연산자 `+` 를 붙이면 아무런 동작도 하지 않지만, 만약 **피연산자가 숫자가 아니라면 숫자형으로의 변환**이 일어난다. 즉 `Number()` 와 동일한 기능을 수행하게 된다.

```js
const num1 = +true; // 1
const num2 = +''; // 0
```

## 할당 연산자 `=`

`x = value` 라는 식을 호출하면 `value` 가 `x`에 쓰여지고 `value` 를 반환한다. 따라서 다음과 같은 표현식이 가능하게 된다.

```js
let a = 1,
  b = 2;
let c = 3 - (a = b + 1); // 0
```

### 할당 연산자 체이닝

`a = b = c = 2+2` 처럼 여러 개의 할당 연산자를 연결할 수 있다.

## 비트 연산자

인수를 32비트 정수로 변환하여 이진 연산을 수행한다.

`&` , `|` , `^` , `~` 와 시프트 연산자 (`<<`, `>>`, `>>>`) 가 있다.

## 쉼표 연산자 `,`

쉼표 연산자는 여러 표현식을 코드 한 줄에서 평가할 수 있게 해주는 연산자로, 모든 표현식을 모두 평가하되 <u>마지막 표현식 평가 결과만 반환</u>된다.

코드를 짧게 쓰고 싶은 경우나 `for문` 에서 가끔 사용된다.

```js
const a = (1+2, 3+4); // 7

for(let i=0;j=9; i<=9; i++, j--) {};
```
아래와 같이 map 함수 내부에서도 사용 가능하다. 연산들을 왼쪽에서부터 모두 실행 후, 값은 마지막 연산 결과값만 반환한다.
```js
const arr = [1,2,3,4,5];

let sum = 0;
arr.map(x => ((sum += x), (x*x);

console.log(sum); // 15
console.log(arr); // [1,4,9,16,25];
```

## 비교 및 일치 연산자

### 비교 연산자

- 문자열끼리 비교 시 사전(유니코드) 순으로 비교
- 형이 다른 값끼리 비교시 <u>숫자형으로 변환</u>하여 비교
- 원시형이 아닌 배열, 일반 객체 등 비교시 참조 값 비교

### 동등 연산자 `==`

동등 연산자(equality operator) `==` 는 <u>형이 다른 피연산자를 숫자형으로 변환</u>하여 비교한다. 불일치 연산자는 `!=`

```js
0 == false; // true
'' == false; // true
```

단, 피연산자가 `undefined` 나 `null` 이라면 숫자형으로 변환하지 않는다. `undefined` 와 `null`를 비교하는 경우에만 true를 반환하고, 이들과 다른 값을 비교할 때는 무조건 false를 반환한다.

### 일치 연산자 `===`

일치 연산자(strict equality operator) `===` 는 자료형의 동등 여부까지 검사한다. 불일치 연산자는 `!==`

## 조건부 연산자 `?`

조건부 연산자 `?` 를 통해 if문을 간결하게 표현할 수 있다. 피연산자가 3개이므로 '삼항 연산자' 라고도 불린다.

```js
const isAdult = age > 20 ? true : false;
```

> if(...) 문은 괄호 안의 값이 falsy 값이면 실행하지 않고, truthy한 값이면 실행한다. falsy vs truthy는 불린형으로 변환했을 때 false가 되는지, true가 되는지를 의미한다.

> switch문을 사용하면 case문의 값과 인자값을 비교할 때 일치 비교(`===`)를 한다. 즉 자료형이 다르면 무조건 false임

## 논리 연산자

`||` 는 첫번째 truthy 값을 찾고, `&&` 는 첫번째 falsy 값을 찾는다.

### OR `||`

```js
result = value1 || value2 || value3;
```

여러개의 피연산자가 있을 때 왼쪽부터 오른쪽으로 나아가며 순서대로 평가한다.

- 각 피연산자를 <u>불린형으로 변환</u>한 후, 만약 변환값이 `true` 라면, 즉 해당 값이 truthy 값이라면 연산을 멈추고 <u>변환 전 원래 값을 반환</u>한다.
- 피연산자 모두를 평가한 경우, 즉 모든 피연산자가 falsy 값이라면 <u>마지막 피연산자 값을 반환</u>한다.

즉 `||` 연산자는 **여러 피연산자들 중 첫번째 truthy 값을 찾아 반환하고, 만약 없다면 마지막 피연산자를 반환**하게 되는 것이다.

truthy 값을 만나면 나머지 값들을 건들이지 않고 즉시 연산을 멈추는 프로세스를 '단락 평가(short circuit evaluation)' 라고 한다.

```js
true || alert('not alert!');
false || alert('alert!');
```

단락 평가는 연산자 왼쪽 조건이 falsy일때만 명령어를 실행하고자 할 때 자주 사용된다.

### AND `&&`

```js
result = value1 && value2 && value3;
```

`||` 와 마찬가지로 여러개의 피연산자가 있을 때 왼쪽부터 오른쪽으로 나아가며 순서대로 평가한다.

- 각 피연산자를 <u>불린형으로 변환</u>한 후, 만약 변환값이 `false` 라면, 즉 해당 값이 falsy 값이라면 연산을 멈추고 변환 전 원래 값을 반환한다.
- 피연산자 모두를 평가한 경우, 즉 모든 피연산자가 truthy 값이라면 <u>마지막 피연산자 값을 반환</u>한다.

즉 `&&` 연산자는 **여러 피연산자들 중 첫번째 falsy 값을 찾아 반환하고, 만약 없다면 마지막 피연산자를 반환**하게 되는 것이다.

### NOT `!`

```js
result = !value;
```

- `!` 연산자는 피연산자를 불린형으로 변환 후, 변환된 값의 역을 반환한다.
- `!!` 으로 NOT을 연달아 사용하면 `Boolean(value)` 와 같이 값을 불린형으로 변환할 수 있다.

## nulllish 병합 연산자 `??`

`??` 연산자를 사용하면 여러 피연산자 중 <u>그 값이 확정되어있는(defined) 변수</u>를 찾을 수 있다. `x = a ?? b` 를 `??` 연산자 없이 작성하면 다음과 같다.

```js
x = a !== null && a !== undefined ? a : b;
```

즉, a가 `null` 도 아니고 `undefined` 도 아니라면 `a` 를 반환하고, 그 외의 경우에는 `b` 를 반환하는 것이다.

### `??` vs `||`

두 연산자는 많은 케이스에서 동일한 결과를 나타내지만, `??` 는 첫번째 정의된 값을 찾아 반환하고 `||` 는 첫번째 truthy 값을 찾아 반환한다는 점에서 차이점이 있다.

```js
height || 100;
height ?? 100;
```

- 만약 `height` 변수에 값이 할당되지 않았다면, 즉 값이 `undefined` 이라면 둘다 100을 반환한다.
- 하지만 만약 `height` 변수 값이 0이라면, 이는 `||` 는 여전히 truthy한 값인 100을 반환하겠지만, `??` 는 정의된 `height` 의 값 0을 반환한다.

따라서 height 처럼 0이 할당될 수 있는 변수를 사용해 기능을 개발할 땐 `??` 가 더 적합하다.
