# 렉시컬 스코프와 클로저

렉시컬 환경, 렉시컬 스코핑, 클로저에 대해 이해하자.

## Lexical Environment

렉시컬 환경(Lexical Environment)이란, <u>함수, 코드 블록 `{}`, 스크립트 전체가 실행되기 앞서 생성되는 특별한 객체</u>이다. 이는 크게 2가지 부분으로 구성된다.

- 환경 레코드(Environment Record): 모든 지역 변수를 프로퍼티로 저장하고 있는 객체
- 외부 렉시컬 환경(Outer Lexical Environment)에 대한 참조

### 변수

스크립트에 아래 세 줄의 코드가 있다고 가정하고, 이를 실행했을 때 어떻게 렉시컬 환경이 변화하는지 살펴보자.

```js
let str;
str = 'hello';
str = 'world';
```

1. 스크립트가 시작되면 이와 관련된 **전역 렉시컬 환경 객체**이 생성된다.
2. 선언된 변수들이 모두 '환경 레코드'의 프로퍼티로 등록된다. 이때 변수의 상태는 `<uninitialized>` 상태로, 이때는 변수를 참조할 수 없다.
3. `let str` 를 만나면 아직 값을 할당하기 전이므로 프로퍼티 값을 `undefined` 로 설정한다. 이후부터는 변수 `str` 를 참조할 수 있다.
4. `str = "hello"` 를 만나면 환경 레코드의 프로퍼티 값이 `hello` 로 변경된다.
5. `str = "world"` 를 만나면 환경 레코드의 프로퍼티 값이 `world` 로 변경된다.

> 변수 선언문에 도달하기까지의 영역을 변수에 접근할 수 없다는 의미로 Temporary Dead Zone(TDZ) 라고도 부른다. 참고로, `let` 이나 `const` 로 변수를 선언한 경우 TDZ에 영향을 받지만, `var` 로 선언한 경우 변수의 값이 처음부터 `undefined` 로 초기화되기 때문에 TDZ에 영향을 받지 않는다.

### 함수 선언문

- 초기에는 값이 `uninitialized` 로 초기화되는 일반 변수와는 달리, **함수 선언문으로 선언된 함수는 완전하게 초기화**된다.
- 즉, 변수는 `let` 이나 `const` 를 만나기 전까지 사용할 수 없는 반면, 함수는 렉시컬 환경이 만들어지는 즉시 사용할 수 있다.

> `let func = function(){...}` 같은 함수 표현식은 해당되지 않는다.

### 내부 및 외부 렉시컬 환경

함수 실행 시, 해당 함수와 연관된 렉시컬 환경이 자동으로 생성된다. 이 렉시컬 환경은 **넘겨 받은 매개변수와 함수 내 지역 변수가 저장되고, 외부 렉시컬 환경에 대한 참조**를 갖게 된다.

```js
let str = 'hello';
function say(name) {
  console.log(`${str} ${name}`);
}
hi('world');
```

1. `hi("world")` 를 통해 `hi` 라는 함수가 호출되면, 새로운 함수 렉시컬 환경 객체가 생성된다.
2. 해당 객체는 함수의 매개변수인`name` 에 대한 정보를 담고 있고, 변수 `str` 와 함수 `say` 를 프로퍼티로 가지고 있는 <u>전역 렉시컬 환경을 외부 렉시컬 환경으로 가리키고 있다</u>.
3. 함수 내에서 콘솔문을 실행할 차례가 되어 변수값을 알아야 한다고 하자. 먼저 내부 렉시컬 환경을 검색 범위로 잡고 변수를 탐색한다. 여기에서 변수 `name` 에 대한 값을 찾을 수 있다.
4. 내부 렉시컬 환경에서 원하는 변수를 찾지 못하면 검색 범위를 '참조하고 있는 외부 렉시컬 환경' 으로 확장한다. 위 코드에서는 외부 렉시컬 환경에서 변수 `str` 에 대한 값을 찾을 수 있다.
5. 이 과정은 검색 범위가 '전역 렉시컬 환경'으로 확장될 때까지 반복되고, 만약 전역 렉시컬 환경에 도달했는데도 변수를 찾지 못하면 에러가 발생한다.

### 함수 반환

모든 함수는 '자신이 정의된 곳의 렉시컬 환경'을 기억한다. 즉, 함수는 `[[Environment]]` 라는 숨김 프로퍼티에 정의된 곳의 렉시컬 환경에 대한 참조를 저장하게 되고, 이를 통해 외부 렉시컬 환경에 대한 참조를 할 수 있다.

이번엔 아래와 같이 함수를 반환하는 `makeCounter` 이라는 함수가 있다고 해보자.

```js
function makeCounter() {
  let count = 0;
  return function () {
    return count++;
  };
}
let count = 100;
let counter = makeCounter();
console.log(counter()); // 1
console.log(counter()); // 2
```

1. `makeCounter()` 가 호출되면 이와 관련된 새로운 렉시컬 환경 객체가 생성된다. 해당 객체 내에는 지역 변수 `count` 가 프로퍼티로 저장되고, 전역 렉시컬 환경을 참조하게 된다.
2. `counter()` 가 호출되면 `makeCounter` 내 익명 중첩 함수가 생성된다. 이때 해당 함수에 대한 새로운 렉시컬 환경이 생성되고, `counter.[[Environment]]` 에는 `makeCounter` 렉시컬 환경에 대한 참조가 저장된다.
3. 이후 함수 내 `count++` 을 실행하기 위해 변수 `count`을 탐색한다. 내부 렉시컬 환경에는 해당 값이 없으니 외부 렉시컬 환경에서 이를 탐색하고, `makeCounter` 내부 `count` 값을 찾으면 이 값을 갱신한다. 변숫값 갱신은 변수가 저장된 렉시컬 환경에서 이루어진다.
4. `counter() `를 여러번 호출해도 모두 같은 외부 렉시컬 환경을 참조하고 있으니 `count` 값이 계속 증가한다.

만약 `counter()` 이 없다면, `makeCounter()` 호출이 종료된 이후 함수 내 변수 `count` 는 가비지 컬렉터의 수거 대상이 되어 메모리에서 제거될 것이다. 그러나, `counter` 함수가 이를 참조 복사하여 가지고 있기 때문에, 가비지 컬렉터는 이 변수를 제거하지 않는다.

## 렉시컬 환경과 실행 컨텍스트

- [실행 컨텍스트](/Language/Javascript/0.Core%20Javascript/Execution%20Context.md)는 함수들의 실행 흐름을 트래킹하기 위한 특별한 자료 구조이다. 이는 현재 실행하고 있는 함수 내 변수와 this 값, 현재 실행 중인 라인 등을 기억하고 있다.
- 실행 컨텍스트는 렉시컬 환경을 포함한 소스 코드를 실행하기 위해 필요한 것들을 관리하는 내부 메커니즘이다.
- 즉, 실행 컨텍스트가 렉시컬 환경 객체를 저장 및 업데이트하고, 코드 소스 실행 중 필요할 때마다 이에 접근해서 값을 갖다 쓰는 것이다.

즉 렉시컬 환경은 함수의 "정의(선언)"과 관련된 개념이고, 실행 컨텍스트는 함수의 "실행"과 관련된 개념이다!

## Scope

스코프(scope)는 **변수와 함수가 유효한 범위**를 의미한다.

- 앞서 <u>전역 스크립트, 코드 블록, 함수</u>는 생성 시 독립적인 렉시컬 환경을 갖는다고 말했다. 전역 스크립트에서 선언된 변수는 어디서든 접근 가능한 '전역 스코프'를 가지게 되고, 코드 블록 내부에서 선언된 변수는 해당 블록 내에서만 접근 가능한 '블록 스코프'를 가지게 되며, 함수 내에서 선언된 변수는 '함수 스코프'를 가지게 된다.
- 앞서 내부 렉시컬 환경에 사용하고자 하는 변수 정보가 없다면, 전역 렉시컬 환경에 다다를 때까지 외부 렉시컬 환경으로 검색 범위를 확장한다고 말했다. 이렇게 변수를 찾기 위해 상위 컨텍스트로 스코프를 넓혀가는 것을 '**스코프 체인(Scope Chain)**' 이라고 한다.
- 변수의 스코프를 결정 짓는 방식은 동적 스코핑과 정적 스코핑으로 나눌 수 있다. 동적 스코핑은 런타임 환경에서 호출된 함수의 실행 컨텍스트에 따라 스코프가 동적으로 결정되는 방식인 반면, 정적 스코핑은 <u>함수가 정의된 위치에 따라 정적으로 결정</u>된다.
- 자바스크립트를 포함한 거의 모든 언어가 '**렉시컬 스코핑(Lexical Scoping)**'을 따른다. 따라서 변수의 스코프는 함수와 변수가 정의된 위치에 따라 결정된다.

## Closure

클로저(closure)란, **외부 변수를 기억하고 이에 접근할 수 있는 함수**를 의미한다.

- 앞서 자바스크립트의 모든 함수는 <u>자신이 선언되었을 때의 환경에 대한 참조</u>를 `[[Environment]]` 프로퍼티에 저장하기 때문에, 선언된 환경 밖에서 함수가 호출되어도 그 환경에 접근할 수 있다고 말했다.
  - 위 `counter` 예시를 다시 보면, `makeCounter` 함수가 종료되어 `counter` 가 변수 `count` 를 참조할 수 없을 것 같아 보여도, 중첩 함수가 자신을 둘러싼 `makeCounter` 의 메모리 환경을 가지고 반환하기 때문에 에러 없이 동작할 수 있다.
