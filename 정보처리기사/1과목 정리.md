# [정보처리기사 1과목] 소프트웨어 설계

### 소프트웨어 공학

- 소프트웨어의 품질과 생산성 향상을 목적 

### 소프트웨어 개발 모델

- 폭포수 모형(Waterfall Model)
  - 개발 과정의 각 단계를 확실히 매듭짓고 그 결과를 철저히 검토 후 승인 과정을 거친 후에 다음 단계를 진행하는 개발 방법론.
  - 전통적인 소프트웨어 생명 주기 모형 (고전적, 구조적)
  - 요구 분석 -> 기획 -> 디자인 -> 개발 -> 테스트 -> 출시
- 나선형 모형(Spiral Model)
  - 보헴이 제안
  - 여러 번의 개발 과정을 거쳐 점진적으로 완벽한 최종 소프트웨어을 개발하는 모델
- 애자일 모형(Agile Model)
  - 고객의 요구사항 변화에 유연하게 대응할 수 있도록 일정한 주기를 반복하면서 개발과정을 진행
  - 고객과의 소통에 초점을 맞춘 방법론 
  - Scrum, XP(eXtreme Programming), Kanban, Lean, Crystal, ASD(Adaptive Software Development), FDD(Feature Driven Development), DSDM(Dynamic System Development Method), DAD(Disciplined Agile Delivery)등이 애자일 모형을 기반에 두고 있다.
  - 4가지 핵심 가치 : 프로세스와 도구보다는 개인과 상호작용에, 방대한 문서보다는 실행되는 소프트웨어에, 계약 협상보다는 고객과 협업에, 계획을 따르기 보다는 변화에 반응하는 것에 더 가치를 둔다. 

### 스크럼(Scrum)

- 팀이 중심이 되어 개발의 효율성을 높인다는 의미를 내포
- 팀원 스스로가 스크럼 팀을 구성하여, 개발 작업에 관한 모든 것을 스스로 해결할 수 있어야 한다.
- 스크럼 팀 구성원 
  - PO(Product Owner, 제품 책임자) : 제품의 요구사항을 책임지고. 의사 결정. 요구사항의 우선순위 갱신.
  - SM(Scrum Master, 스크럼 마스터) : 스크럼이 잘 수행될 수 있도록 객관적인 시각에서 조언. 팀원 통제는 X. 회의 주관. 장애 요소 공론화 등
  - DT(Development Team, 개발팀) : PO, SM을 제외한 모든 팀원. 개발자 및 디자이너, 테스터 포함해서 보통 7~8명이 적당.
- 개발 프로세스
  - Product Backlog : 모든 요구사항을 우선순위에 따라 나열한 목록
  - Spring Planning Meeting : 이번 스프린트에서 수행할 작업을 대상으로 단기 일정을 수립 
  - Sprint : 실제 개발 작업을 진행하는 과정. 보통 2~4주 기간 내 진행. 백로그 내 테스크들을 속도에 맞게 개별 담당자에게 할당
  - Daily Scrum Meeting : 매일 약속된 시간에 약 15정도의 시간동안 진행 상황 점검. 보통 서서 진행. 
  - Sprint Review : 부분 혹은 전체 완성 제품이 요구사항에 부합되는지 테스팅 수행
  - Sprint Retrospective(회고) : 스프린트 주기를 되돌아보며 규칙을 준수했는지, 개선점은 무엇인지 등 회고하고 기록 

### XP(eXtreme Programming)

- 수시로 발생하는 고객의 요구사항에 유연하게 대응하기 위해 고객의 참여와 개발 과정 반복을 극대화
- 릴리즈 기간을 짧게 반복함으로 고객의 요구사항 반영에 대한 가시성 높임
- 5가지 핵심 가치 : 의사소통. 단순성. 용기. 존중. 피드백
- 주요 실천 방법
  - Pair Programming : 다른 사람과 함께 프로그래밍을 진행함으로써 개발에 대한 책임을 공동으로 갖음
  - Collective Ownership : 코드에 대한 권한과 책임을 공통으로 소유
  - TDD(Test-Driven Development) : 코드 작성 전에 테스트 케이스를 먼저 작성하여 무엇을 할지 파악. 자동화된 테스팅 도구 사용 
  - Whole Team : 개발에 참여하는 모든 구성원은 자신의 역할이 있고, 그 역할에 대한 책임을 가짐.
  - Continuous Integration : 모듈 단위로 나눠 개발된 코드들은 지속적으로 통합
  - Design Improvement or Refactoring : 단순화, 유연성 강화 등
  - Small Releases : 짧은 릴리즈 기간을 반복

### 현행 시스템 파악

- 1단계 : 시스템 구성 파악. 시스템 기능 파악. 시스템 인터페이스 파악
- 2단계 : 아키텍처 구성 파악. 소프트웨어 구성 파악
- 3단계 : 하드웨어 구성 파악. 네트워크 구성 파악

### 운영 체제(Operating System)

- 컴퓨터 시스템 자원들을 효율적으로 관리하고, 사용자가 컴퓨터를 편리하고 효율적으로 사용할 수 있도록 환경을 제공하는 소프트웨어
- 응용 프로그램이 유용한 작업을 할 수 있도록 환경 제공
- 컴퓨터 운영체제는 Window. UNIX. Linux. Mac OS, 모바일 운영체제는 IOS. Android 있다.

### DBMS(Database Management System)

- 사용자의 요구에 따라 정보를 생성하고, 데이터베이스를 관리하는 소프트웨어
- 데이터의 종속성과 중복성의 문제를 해결. 모든 응용 프로그램들이 데이터베이스를 공용으로 사용 가능
- Oracle, IBM DB2, Microsoft SQL Server, MySQL, SQLite, MongoDB, Redis 등

### WAS(Web Application Server)

- 정적인 콘텐츠 처리를 하는 웹 서버와 달리, 사용자의 요구에 따라 변화하는 동적인 콘텐츠를 처리하기 위해 사용되는 미들웨어
- 데이터 접근, 세션 관리, 트랜잭션 관리 등 담당 
- Tomcat, GlassFish, JBoss, Jetty, JEUS, Resin, WebLogic, WebSphere 등 

> 웹 서버에는 Apache, NginX, IIS 등이 있다.

### 소프트웨어 요구사항 

- 소프트웨어가 어떤 문제를 해결하기 위해 제공하는 서비스에 대한 설명과 정상적으로 운영되는데 필요한 제약 조건 등
- 기능 요구사항과 비기능(보안, 인터페이스, 관리 등) 요구사항 
- 요구사항 개발 프로세스
  - 요구사항 도출(Elicitation) : 브레인스토밍, 프로토타이핑, 유스케이스 등 사용 
  - 요구사항 분석(Anaylsis) : 요구사항의 타당성 분석. 비용과 일정 제약 등 설정. 자료 흐름도(DFD), 자료 사전(DD) 등 사용
  - 요구사항 명세(Specification) : Mini-Spec 등 사용
  - 요구사항 확인(Validation) : 명세서 검토 
- 명세 기법
  - 정형 명세 기법 : 수학적 원리 기반, 모델 기반. 간결한 표현. VDM, Z, Petri-net, CSP 등
  - 비정형 명세 기법 : 상태/기능/객체 중심. 자연어 사용으로 이해 쉬움. FSM, Decision Table, ER Model, State Chart 등 

### DFD(Data Flow Diagram)

- 자료 흐름도. 자료 흐름 및 변환 과정과 기능을 도형 중심으로 기술하는 방법 
- Process, Data Flow, Data Store, Terminator

### DD(Data Dictionary)

- 데이터를 설명하는 데이터. 메타 데이터(Meta Data)

### HIPO(Hierarchy Input Process Output)

- 시스템 분석 및 설계나 문서화할 때 사용되는 기법 

### UML(Unified Modeling Language)

- 시스템 개발 과정에서 의사소통이 원활하게 이루어지도록 표준화한 대표적인 **객체지향 모델링 언어**
- 사물, 관계, 다이어그램 등으로 구성 
- 관계
  - 연관 관계 
  - 집합 관계
  - 포함 관계
  - 일반화 관계
  - 의존 관계
  - 실체화 관계
- 다이어그램
  - 구조적 다이어그램(정적 모델링)
    - 객체 다이어그램, 컴포넌트 다이어그램, 배치 다이어그램, 복합체 구조 다이어그램, 패키지 다이어그램
    - 클래스 다이어그램(Class Diagram) : 
  - 행위 다이어그램(동적 모델링)
    - 커뮤니케이션, 상태, 활동, 상호작용 개요, 타이밍 다이어그램 
    - 유스케이스 다이어그램(Usecase Diagram) : 
    - 순차 다이어그램(Sequence Diagram) :

### Stereotype

- UML에서 표현하는 기본 기능 외에 추가적인 기능을 표현
- `<<>>` (guilemet) 을 사용하여 표현
- `<<include>>` : 포함 관계
- `<<extend>>` : 확장 관계
- `<<interface>>` 
- `<<exception>> `
- `<<constructor>>`

### UI(User Interface)

- 사용자의 만족도에 가장 큰 영향을 미치는 중요한 요소. 변경이 가장 많이 발생.

- 사용자의 편리성과 가독성을 높임. 사용자 중심의 상호 작용. 

- UI 구분

  - CLI(Command Line Interface) : 명령과 출력이 텍스트로 구성

  - GUI(Graphical User Interface) : 메뉴와 아이콘을 마우스로 선택

  - NUI(Natural User Interface) : 사용자의 말이나 행동으로 기기 조작 

  - VUI(Voice User Interface) : 사용자의 음성으로 기기 조작

  - OUI(Organic User Interface) : 모든 사물과 사용자 간의 상호작용을 위한 인터페이스. IoT, VR, AR, MR(Mixed) 등과 함께 대두

- 기본 원칙 : 직관성, 유효성, 학습성, 유연성 

- 설계 지침 : 사용자 중심, 사용성, 심미성(가독성 높이는 설계), 오류 발생 해결(사용자가 오류를 쉽게 인지할 수 있도록 해야함) 

- 설계 도구
  - 와이어프레임 : 기획 단계에 뼈대 설계. 파워포인트, 스케치, 키노트 등 
  - 목업 : 와이어프레임보다 더 실제 화면과 유사하게 만든 정적인 형태의 모형. 파워 목업, 발사믹 목업 등 
  - 스토리보드 : 콘텐츠 설명, 페이지 간 이동 흐름 등 추가한 문서. 최종적으로 참고하는 작업 지침서. Axure, 파워포인트 등
  - 프로토타입 : 인터렉션 적용된 테스트 가능한 동적인 형태의 모형. 사용성 테스트 나 서비스 이해를 위한 샘플
  - 유스케이스 : 사용자 측면에서의 요구사항

### 품질 요구사항

- 소프트웨어의 기능, 성능, 만족도 등 소프트웨어에 대한 요구사항 
- ISO/IEC 9126. 25010. 12119. 14598 : 소프트웨어 품질 특성과 평가를 위한 표준 지침
- 기능성, 신뢰성, 사용성, 효율성, 유지 보수성, 이식성

### 소프트웨어 설계

- 상위 설계 : 아키텍처 설계, 예비 설계. 구조, DB, 인터페이스 등 대상
- 하위 설계 : 모듈 설계, 상세 설계. 컴포넌트, 자료 구조, 알고리즘 등 대상

### 소프트웨어 아키텍처 설계

- 기본 원리 : 모듈화(Modularity). 추상화(Abstraction). 단계적 분해(Stepwise Relinement). 정보 은닉(Infomation Hiding)

- 품질 속성 
  - 시스템 측면 : 성능, 보안, 가용성, 기능성, 사용성, 변경 용이성, 확장성
  - 비즈니스 측면 : 시장 적시성, 비용/혜택, 예상 시스템 수명 
  - 아키텍처 측면 : 개념적 무결성, 정확성, 완결성, 구축 가능성 
- 설계 과정 : 목표 설정 -> 시스템 타입 결정 -> 아키텍처 패턴 적용 -> 서브 시스템 구체화 -> 검토

### 협약에 의한 설계

- 소프트웨어 컴포넌트에 대한 정확한 인터페이스 명세

- 명세에 포함될 조건

  - 선행 조건(Precondition) : 오퍼레이션이 호출되기 전 만족되어야할 조건

  - 결과 조건(Postcondition) : 오퍼레이션이 수행된 후 만족되어야할 조건

  - 불변 조건(Invariant) : 오퍼레이션이 수행되는 동안 항상 만족되어야할 조건


### 아키텍처 패턴

- Pipe-Filter Pattern
- Model-View-Controller Pattern
- Master-Slave Pattern
- Broker Pattern
- Peer-To-Peer Pattern
- Event-Bus Pattern
- Blackboard Pattern
- Interpreter Pattern

### 객체 지향 관련 개념들

- 객체(Object) 
  - 데이터와 데이터를 처리하는 함수를 묶어 놓은 하나의 소프트웨어 모듈
  - 데이터는 속성이나, 상태, 분류등을 나타낼 수 있음
  - 함수는 객체가 수행하는 기능으로 메서드, 서비스, 연산이라고도 함
- 클래스(Class)
  - 공통된 속성과 연산(행위)를 갖는 객체의 집합
  - 객체의 일반적인 타입이자. 각각의 객체들이 갖는 속성과 연산을 정의하고 있는 틀. 데이터를 추상화
  - 클래스에 속한 각각의 객체를 **인스턴스**(Instance) 라고 함.

- 캡슐화(Encapsulation)
  - 데이터와 데이터를 처리하는 함수를 하나로 묶는 것
  - 인터페이스를 제외한 세부 내용이 은폐되어 외부에서의 접근이 제한적. 재사용이 용이
- 상속(Inheritance)
  - 상위 클래스의 모든 속성과 연산이 하위 클래스가 물려받는 것
  - 하위 클래스는 상위 클래스의 속성과 연산을 다시 정의하지 않고 사용할 수 있고, 또 새로운 속성과 연산 첨가 사용 가능
- 다형성(Polymorophism)
  - 메세지에 의해 객체가 연산을 수행하게 될 때 하나의 메세지에 대해 **각각의 객체가 가지고 있는 고유한 방법**으로 응답할 수 있는 능력 
  - **Overloading(오버로딩)**은 메서드 이름은 같지만, 인자(인수)를 받는 자료형이나 개수를 달리하여 여러 기능을 정의할 수 있도록 하는 것.
  - **Overriding(오버라이딩)**은 상위 클래스에서 정의한 메서드를 하위 클래스에서 같은 이름으로 재정의하되, 실행 코드를 달리하여 사용하는 것.
- 연관성(Relationship)
  - is memeber of : 연관화(association) -> 2개 이상 객체가 상호 관련되어 있음
  - is instance of : 분류화(classification) -> **동일한 형의 특성을 갖는 객체들**을 모아 구성
  - is part of : 집단화(aggregation) -> 관련 있는 객체들을 묶어 **하나의 상위 객체**를 구성
  - is a 
    - 일반화(generalization) -> 공통적인 성질들로 추상화한 상위 객체를 구성
    - 특수화/상세화(specialization) -> 상위 객체를 구체화하여 하위 객체를 구성

### 객체지향 분석 방법론

- **Rumbaugh(럼바우) 방법**
  - 모든 소프트웨어 구성 요소를 그래픽 표기법을 이용하여 모델링하는 기법
  - **객체 모델링 기법**. OMT(Object-Modeling Technique) 라고도 함
  - 객체 모델링 : 시스템에서 요구되는 객체를 찾아내어 속성과 관계 등을 규정하여 다이어그램으로 표시
  - 동적 모델링 : 상태 다이어그램을 이용하여 시간의 흐름에 따른 객체 간의 제어 흐름, 상호 작용 등 동적인 행위 표시
  - 기능 모델링 : 자료 흐름도(DFD) 이용하여 다수의 프로세스들 간 자료 흐름을 중심으로 처리 과정 표시
  - 객체 모델링 -> 동적 모델링 -> 기능 모델링 순으로 진행
- Booth(부치) 방법 : 미시적 개발 프로세스와 거시적 개발 프로세스를 모두 사용. 클래스와 객체 분석 및 식별 후 클래스 정의
- Jacobson 방법 : Use Case 강조 및 사용
- Coad & Yourdon 방법 : E-R 다이어그램 사용하여 객체의 행위 모델링. 
- Wirls-Brock 방법 : 분석과 설계 간의 구분 X. 고객 명세서 평가해서 설계 작업까지 연속적으로 수행

### 객체지향 설계 원칙(SOLID 원칙)

- 단일 책임 원칙(Single Responsibility Principle) : 객체는 단 하나의 책임만 가져야 한다. 
- 개방-폐쇄 원칙(Open-Closed Principle) : 기존 코드를 변경하지 않고도 기능을 추가할 수 있어야 한다.
- 리스코프 치환 원칙(Liskov Substitution Principle) : 자식 클래스는 부모 클래스에서 가능한 행위는 수행할 수 있어야 한다.
- 인터페이스 분리 원칙(Interface Segregation Principle) : 자신이 사용하지 않는 인터페이스와는 의존 관계를 맺거나 영향을 받지 않아야 한다.
- 의존 역전 원칙(Dependency Inversion Principle) : 추상성이 낮은 클래스보다 높은 클래스와 의존 관계를 맺어야 한다.

### 결합도(Coupling)

- **모듈 간에 상호 의존하는 정도** 또는 두 모듈 사이의 연관 관계를 의미 
- 결합도가 약할수록 모듈 품질도가 높다. 결합도가 강하면 시스템 구현 및 유지보수가 어려워진다.
- 자료 결합도
- 스탬프(검인) 결합도
- 제어 결합도
- 외부 결합도
- 공통(공유) 결합도
- 내용 결합도

### 응집도(Cohesion)

- 명령어나 호출문 등 **모듈의 내부 요소들의 서로 관련되어 있는 정도**, 즉 모듈이 독립적인 기능으로 정의되어 있는 정도
- 응집도가 강할수록 품질이 높다. 
- 기능적 응집도
- 순차적 응집도
- 교환적 응집도
- 절차적 응집도
- 시간적 응집도
- 논리적 응집도
- 우연적 응집도

### 팬인(Fan-In) / 팬아웃(Fan-Out)

- 팬인 : 어떤 모듈을 **제어/호출하는** 모듈의 수
- 팬아웃 : 어떤 모듈에. 의해 **제어/호출되는** 모듈의 수
- (ex) A -> B -> C 순으로 모듈이 사용된다고 가정하면, A,B,C의 팬인은 각각 0,1,1 이고 팬아웃은 각각 1,1,0 이다.

### 효과적인 모듈 설계 방안 

- **결합도는 줄이고 응집도는 높여서** 모듈의 독립성과 재사용성을 높인다. 
- 복잡도와 중복성을 줄이고. 일관성을 유지. 유지보수가 용이하도록. 
- 모듈 간의 계층적 관계를 정의하는 자료가 제시되어야 한다. 

### 코드(Code)

- 컴퓨터를 이용하여 자료를 처리하는 과정에서 분류. 조합 및 집계를 용이하게 하고, 특정 자료의 추출을 쉽게 하기 위해 사용되는 기호
- ex. 주민등록번호, 학번, 전화번호 등 
- 식별 기능, 분류 기능, 배열 기능, 표준화 기능, 간소화 기능
- 순차 코드 : 일정 기준에 따라 일련번호 부여
- 블록 코드: 공통성 있는 것끼리 블록으로 구분 
- 10진 코드 : 0~9까지 10진 분할. 다시 각각에 대해 10진 분할.. 도서 분류식 코드
- 그룹 분류 코드 : 일정 기준에 따라 대분류, 중분류, 대분류.. 그 내에서 일련번호 부여
- 연상 코드 
- 표의 숫자 코드
- 합성 코드

### 디자인 패턴 

<img width="493" alt="스크린샷 2023-01-22 18 30 07" src="https://user-images.githubusercontent.com/67703882/213908975-7eaf0a48-44b8-4fe4-94b6-46849e4352b5.png" >

### 미들웨어(Middleware)

- 운영체제와 응용 프로그램, 또는 서버와 클라이언트 사이에서 다양한 서비스를 제공하는 소프트웨어
- DB : 클라이언트에서 원격의 데이터베이스와 연결하기 위한 미들웨어
- RPC(Remote Procedure Call) : 응용 프로그램의 프로시저를 사용하여 원격 프로시저를 마치 로컬 프로시저처럼 호출하는 방식의 미들웨어
- MOM(Message Oriented Middleware) : 메세지 기반의 비동기형 메세지를 전달하는 방식의 미들웨어. 온라인 업무보다는 분산 데이터 시스템의 데이터 동기화를 위해 사용
- TP-Monitor(Transaction Processing Monitor) : 온라인 트랜잭션 업무(예약 등)에서 트랜잭션을 처리 및 검사하는 미들웨어
- ORB(Object Request Brocker) : 객체 지향 미들웨어로 코바 표준 스펙을 구현한 미들웨어. (최근에는 트랜잭션 모니터링 기능까지 추가되기도)
- WAS(Web Application Server) : 사용자 요구에 따라 변하는 동적 컨텐츠를 처리하기 위한 미들웨어
