# 정보처리기사 실기 정리

# 1. 소프트웨어 공학

- 소프트웨어 개발 주기 (SDLC : Software Development Life Cycle)
  ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f649b004-aa33-40c5-b31f-2778f60e7a9c/Untitled.png)
  프로젝트 수행 계획 → 문제점 파악 및 사용자 인터뷰 등 통해 요구 분석하여 다이어그램으로 표현 → 다이어그램을 코딩할 수 있는 환경으로 구체화(설계) → 프로그램 코드 작성 → 여러 테스트 기법으로 테스트 → 사용자 피드백 기반으로 유지보수

## 계획 단계

- **소프트웨어 프로세스 모델 (생명주기 모형)**
  1. 폭포수 모형(Waterfall Model) : 각 단계에서 결과물을 완벽하게 만들어 낸 후 다음 단계 진행
  2. 프로토타입 모형(Prototype Model, 원형 모델) : 프로토타입 만들어 사용자 요구사항 파악
  3. 나선형 모형(Spiral Model, 점진적 모형) : 여러번 개발 과정 거침. 보헴씨가 제안.
  4. 애자일(Agile Model) : 사용자 요구사항에 유연하게 대응하기 위해 일정한 주기 반복하며 개발. Scrum, Xp, 칸반, Lean, 기능 중심 개발(FDD) 등 관련
  - Scrum : 팀이 중심이 되어 개발 효율성 향상. 팀원 스스로가 스크럼 팀 구성하고 작업에 관한 모든 것을 해결 가능해야함.
  - Xp(eXtreme Programming) : 고객의 참여와 개발 과정의 반복 극대화하여 개발 생산성 향상.
    - 핵심 가치 → 의사소통, 단순성, 용기, 존중, 피드백
    - Pair Programming, Collective Ownership, TDD(Test-Driven Dev), Whole Team, CI(Continuous Integration), Refactoring, Small Releases 등 수행 방법
- 개발 비용 산정 방법
  - 하향식 비용 산정 : 전문 지식 많은 개발자들이 회의를 통해 선정.
    - 전문가 감정. 델파이 기법(전문가 감정의 주관적 편견 보완하기 위해 많은 전문가 의견 종합)
  - 상향식 비용 산정 : 프로젝트 세부 작업 단위별로 비용 산정 후 집계.
    - LOC(source Line of Code), 개발 단계별 인월 수 기법, 수학적 산정 기법
        <aside>
        💡 비관치는 가장 많이 측정된 코드 수. 낙관치는 가장 적게 측정된 코드 수. 기대치는 모든 코드 라인 수의 평균.
        
        </aside>
        
        <aside>
        💡 노력 = 개발기간 * 투입기간 = LOC / 1인당 월평균 생산 코드 라인 수
        개발 비용 = 노력 * 단위 비용(1인당 월평균 인건비)
        개발 기간 = 노력 / 투입 인원
        생산성 = LOC / 노력
        
        </aside>

    - 개발 단계별 인월수 기법 (Effort Per Task) : LOC 기법보다 정확
    - 수학적 산정 기법 : 경험적 추정, 실험적 추정 ex) COCOMO, Putnam(노력 분포 예상), FP 모형(가중치 부여, 알브레히트 제안) 등
  - COCOMO (Constructive Cost Model) 모형
    - LOC에 의한 비용 산정 기법. 프로젝트에 필요한 노력(인월). 보헴씨가 또 제안
    - 조직형(organic mode) : 중.소규모, 5만 라인 이하, 업무용 등
    - 반분리형(semi-detached mode) : 30만 라인 이하, 유틸리티 개발 등
    - 내장형(embedded mode) : 초대형, 30만 이상, 시스템 프로그램 개발
  - 비용 산정 자동화 추정 도구 : SLIM(Putnam 예측 모델 기초), ESTIMACS(FP 모형 기초)
- 프로젝트 일정 계획
  - WBS(Work Breakdown Structure) : 업무 분담하기
  - 네트워크 차트(PERT/CPM) : 프로젝트 관련해서 이것저것 알아보기 위한 도구
    - PERT : Program Evaluation and Review Technique. 진행 상황을 통계적인 방법으로 파악
    - CPM : Critical Path Method. 작업 소요 기간 예측. 임계 경로는 여유 시간이 없는 경로 즉 젤 오래 걸리는 것
      ![스크린샷 2023-07-21 02.10.13.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b734e2d4-3374-4da9-9966-878485c356a6/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-07-21_02.10.13.png)
    - 간트 차트 : 작업 시작 종료를 막대 도표로 확인 가능

## 요구사항 분석 단계

- 요구사항 : 소프트웨어가 운영되는데 필요한 제약 조건
  - 기능 요구사항 : 기능, 수행 관련
  - 비기능 요구사항 : 품질이나 제약 사항 관련
  - 사용자 요구사항 : 사용자 관점에서 본 시스템이 제공해야할 것들
  - 시스템 요구사항 : 개발자 관점에서 본 시스템이 제공해야할 것들 (소프트웨어 요구사항)
- 요구 분석 명세서 : 요구사항을 추출하여 정리한 문서
- 요구사항 개발 프로세스 : 도출 → 분석 → 명세 → 확인
  - 요구사항 도출(수집) : 인터뷰, 설문, 브레인스토밍, 워크샵, 프로토타이핑, 유스케이스 등
  - 요구사항 분석 : 요구사항 중 걸러낼 건 걸러내기 → 자료 흐름도(DFD), 자료사전(DD) 등
  - 요구사항 명세 : 모델 작성 및 문서화
    - 정형 명세 : 수학적 원리 기반. 정확 및 간결 → VDM, Z, Petri-net, CSP
    - 비정형 명세 : 상태/기능/객체 중심. 자연어 기반 → FSM, Decision Table, ER모델링, State Chart(SADT)
  - 요구사항 확인 : SCM
- 구조적 분석 기법 : DFD(자료 흐름도), DD(자료사전), Mini-Spec(소단위 명세서), ERD(개체 관계도), STD(상태 전이도), UML
  - DFD : 자료의 흐름 및 변환 과정, 기능. 도형 중심으로 기술
    ![스크린샷 2023-07-21 14.22.16.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cdb3818b-21a7-4b65-9801-b673fc456ee7/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-07-21_14.22.16.png)
  - DD : 메타 데이터
    ![스크린샷 2023-07-21 14.23.01.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e95692da-51f0-4b46-ac8b-dc5326644cba/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-07-21_14.23.01.png)
- 요구사항 분석 도구
  - 요구사항 분석용 CASE(자동화 도구)
    - SADT
    - SREM=RSL/REVS
    - PSL/PSA
    - TAGS
  - HIPO(Hierachy Input Process Output) : 하향식 소프트웨어 개발. 기능과 자료 의존 관계 동시에 표현 가능. 기호, 도표 사용하므로 보기 쉽고 이해 쉬움
- UML → 사물, 관계, 다이어그램
  - 사물 : 구조 사물, 행동 사물, 그룹 사물, 주해 사물
  - 관계
    - 연관 관계 : 서로 관련되어 있음 → 사람과 집
    - 집합 관계 : 하나의 사물이 다른 사물에 포함되어 았음 → 컴퓨터와 프린터
    - 포함 관계 : 포함하는 사물의 변화가 포함되는 사물에 영향 미침 → 문과 열쇠
    - 일반화 관계 : 하나의 사물이 다른 사물에 비해 더 일반적 → 동물과 코끼리
    - 의존 관계 : 연관은 있는데 서로에게 영향 주는 시간 짧음 → 등급과 할인율
    - 실체화 관계 : 사물이 할 수 있거나 해야하는 기능 → 헤엄치다 - 수영 선수
  - 다이어그램 : 사물과 관계를 도형으로 표현
    - 정적 모델링 → 구조적 다이어그램
    - 동적 모델링 → 행위 다이어그램
  - **구조적 다이어그램**
    - 클래스 다이어그램
    - 객체 다이어그램
    - 컴포넌트 다이어그램
    - 배치 다이어그램
    - 복합체 구조 다이어그램 (Composite Structure Diagram)
    - 패키지 다이어그램
  - **행위 다이어그램**
    - 유스케이스 다이어그램 : 사용자 요구 분석
    - 시퀀스 다이어그램 : 시스템이나 객체가 주고받는 메세지 표현
    - 커뮤니케이션 다이어그램 : 메세지와 객체들 간의 연관 관계 표현
    - 상태 다이어그램 : 상태 변화 → 동적 모델링
    - 활동 다이어그램 : 기능 처리의 흐름
    - 상호작용 개요 다이어그램
    - 타이밍 다이어그램 : 객체의 상태 변화 + 시간 제약

## 설계 단계

![스크린샷 2023-07-21 15.23.56.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/36c96166-97c3-4d9f-aad5-981d7b6795f6/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-07-21_15.23.56.png)

- 설계 원리
  - 분할과 정복 : 세분화된 작은 시스템 개발 → 올라가면서 완성시킴
  - 모듈화 : 시스템 모듈 단위로 나눔
  - 추상화 : 전체적이고 포괄적인 개념 → 차례로 세분화 및 구체화
  - 단계적 분해 : 상위 중요 개념 → 하위 개념. Niklaus Wirth씨가 제안
  - 정보 은닉 : 모듈 내부에 절차와 자료 정보 감추어져 외부에서 접근 불가
- **소프트웨어 아키텍처 패턴**
  - Layer Pattern
  - Client-Server Pattern
  - Pipe-Filter Pattern
  - MVC(Model-View-Controller Pattern)
  - Master-Slave Pattern
  - Broker Pattern
  - Peer-to-Peer Pattern
  - Event-Bus Pattern
  - Blackboard Pattern
  - Interpreter Pattern
- 객체 지향의 특징 → 캡슐화, 상속, 추상화, 다형성/연관성
  - 오버로딩(overloading) : 한 클래스 내에서 매개변수 형태가 다른 동일한 이름의 메서드들을 여러개 구현
  - 오버라이딩(overriding) : 부모 클래스로부터 상속받은 메서드를 자식 클래스가 재정의
- 연관성
  - `is member of` → 연관화
  - `is instance of` → 분류화 (동일한 형의 특정을 갖는 객체끼리)
  - `id part of` → 집단화
  - `is a` → 일반화 or 특수화/상세화
- 객체지향 설계 원칙(SOLID)
  - SRP : Single Responsibility Principle. 한 클래스는 하나의 책임만
  - OCP : Open Closed Principle. 확장은 쉽게, 변경은 어렵게
  - LSP : Liskov Substitution Principle. 자식 클래스는 최소한 부모 클래스의 기능은 수행해
  - ISP : Interface Segregation Principle. 사용하지 않는 인터페이스와는 의존 관계 안맺어
  - DIP : Dependency Inversion Principle. 추상성이 높은 클래스와 의존 관계 맺어
- **Gof 디자인 패턴 - 생성 패턴**
  - 추상 팩토리
  - 빌더
  - 팩토리 메서드
  - 프로토타입
  - 싱글톤
- **Gof 디자인 패턴 - 구조 패턴**
  - 어뎁터
  - 브리지 : Bridge. 기능을 처리하는 클래스와 구현을 담당하는 추상 클래스 구별. 기능 새로 추가할때 유용
  - 컴포지트
  - 데코레이터
  - 퍼싸드
  - 플라이웨이트
  - 프록시 : Proxy.
- **Gof 디자인 패턴 - 행위 패턴**
  - 책임 연쇄
  - 커맨드
  - 인터프리터
  - 반복자
  - 중재자
  - 메멘토
  - 옵서버 : Observer. 한 객체의 상태가 변화하면 객체에 상속되어 있는 다른 객체들에게도 변화된 상태를 전달. 이벤트 발행 및 수신
  - 상태
  - 전략
  - 템플릿 메서드
  - 방문자
- 결합도 → 결합도가 약할수록 품질이 높다. (아래로 갈수록 결합도 낮음)
  - 내용 결합도
  - 공통 결합도
  - 외부 결합도
  - 제어 결합도
  - 스탬프(검인) 결합도
  - 자료 결합도
- 응집도 → 응집도가 강할수록 품질이 높다.
  - 기능적 응집도
  - 순차적 응집도
  - 교환 통신적 응집도
  - 절차적 응집도
  - 시간적 응집도
  - 논리적 응집도
  - 우연적 응집도

## 테스트 단계

- 테스트의 기본 원리
  - 완벽한 테스트는 불가능
  - 파레토 법칙(20%에 해당하는 코드애서 전체 결합의 80%를 발견)
  - 살충제 패러독스(동일한 테스트 케이스로 동일한 테스트를 반복하면 더이상 결합 발생 안돼)
  - 테스팅의 정황 의존
  - 오류-부재의 궤변 : 결국 사용자 요구사항이 제일 중요. Absence of Erros Fallacy
  - 테스트와 위험은 반비례
  - 테스트는 점직적으로 확대하며 수행하고, 별도의 팀을 두어 수행해야함.
- 프로그램 실행 여부에 따른 테스트
  - 정적 테스트 : 걍 명세서나 소스코드만 보고 분석 → 동료 검토, 워크스루, 인스팩션, 코드 리뷰
  - 동적 테스트 : 실행하여 오류 찾기 → 블랙박스, 화이트박스 테스트
- 테스트 기반에 따른 테스트
  - 명세 기반 테스트 : 사용자 요구사항에 대한 명세를 빠짐없이 테스트 케이스로 구현 → 블랙박스
  - 구조 기반 테스트 : 소프트웨어 내부 논리 흐름에 따라 테스트 케이스 작성 → 화이트박스
  - 경험 기반 테스트 : 테스터의 경험 기반
- 시각에 따른 테스트
  - 검증 테스트
  - 확인 테스트
- 목적에 따른 테스트
  - 회복 테스트
  - 안전 테스트
  - 강도 테스트
  - 성능
  - 구조
  - 회귀
  - 병행
- **화이트박스 테스트**
  - 기준 : 문장 검증 기준, 분기 검증 기준, 조건 검증 기준, 분기 조건 기준
  - 기초 경로 검사
  - 제어 구조 검사
    - 조건 검사
    - 루프 검사
- **블랙박스 테스트 → 경계값 분석, 동등 분할, 원인-결과 그래프, 비교 (경동원빈)**
  - 동등 분할 검사
  - 경계값 분석 : 입력 조건의 경계값을 테스트 케이스로 선정
  - 원인 - 효과 그래프 검사
  - 오류 예측 검사
  - 비교 검사
- 개발 단계에 따른 애플리케이션 테스트
  - 단위 테스트
  - 통합 테스트
    - 하향식 통합 테스트
    - 상향식 통합 테스트
  - 시스템 테스트
  - 인수 테스트
- 테스트 오라클 : 테스트 결과가 올바른지 판단 → 참 오라클, 샘플링 오라클, 추정 오라클, 일관성 검사 오라클
- 테스트 하네스 : 테스트 실행 환경 시뮬레이션
  - 테스트 드라이버
  - 테스트 스텁
  - 테스트 슈트
  - 테스트 케이스
  - 테스트 스크립트
  - 목 오브젝트
- **인수 테스트 > 시스템 테스트 > 통합 테스트 > 단위 테스트**

## 품질

- ISO/IEC 12207 : ISO 만든 표준 소프트웨어 생명 주기 프로세스
- CMMI(Capability Maturity Model Integration) : 개발 조직의 능력과 성숙도 평가
  - 초기, 관리, 정의, 정량적 관리, 최적화
- SPICE(Software Process Improvment and Capability dEtermination) : 소프트웨어 프로세스 평가 및 개선하는 국제 표준

## 패키징

- 형상 관리(SCM. Software Configuration Management)
  - 공유 폴더 방식 → SCCS, RCS, PVCS, QVCS
  - 클라이언트/서버 방식 → CVS, SVN(Subversion), CVSNT, Clear Case, CMBC, Perforce
  - 분산 저장소 방식 → Git, GNU arch, DCVS, Bazaar, Bitkeeper …

## 화면 설계

- UI(User Interface)
  - CLI : Command Line I
  - GUI : Graphical User I
  - NUI : Natural User I
  - OUI : Organic User I
- UI 의 기본 원칙 → 직관성, 유효성, 학습성, 유연성
- UI 설계 도구
  - 와이어프레임
  - 목업
  - 스토리보드
  - 프로토타입
  - HCI
- UX(User Experience)

## 기타 용어

- 소프트웨어 재사용
  - 합성 중심(composition-based) : 블록을 끼우는 것처럼 사용
  - 생성 중심(generation-based) : 추상화 형태로 쓰여진 명세를 구체화
- 소프트웨어 재공학 : 기존 시스템에 새기능 추가해서 성능 향상
- CASE(Computer Aided Software Engineering) : 걍 다 자동화 해버리기
- 소프트웨어 개발 프레임워크
  - ex. 스프링, 전자정부, 닷넷 등
  - 모듈화, 재사용성, 확장성, 제어의 역흐름(프레임워크가 객체를 개발자 대신 제어)
- 순환 복잡도 : 프로그램의 논리적인 복잡도 측정 → `화살표 개수 - 노드 수`

# 2. 데이터베이스

## 데이터베이스 개요

- DBMS(Database Management System)
  - 데이터의 종속성과 중복성 문제 해결
  - 필수 기능 : **정의**(데이터 타입 및 구조, 이용방식 등 정의), **조작**(검색, 갱신 삽입 등), **제어**(데이터 무결성, 보안, 권한 검사 등)
- DBS(Database System) : DB랑 DBMS 이용해서 조직 필요한 정보 제공하는 전체 시스템
- 3단계 데이터베이스 구조
  - 외부 스키마
  - 개념 스키마
  - 내부 스키마
- 데이터 독립성 : 논리적, 물리적 독립성
- 데이터 언어
  - DDL(데이터 정의어) → `create` , `alter` , `drop`
  - DML(데이터 조작어) → `select` , `update` , `insert`, `delete`
  - DCL(데이터 제어어) → `grant` , `revoke`
- 데이터 모델링 : 개념적 모델링, 논리적 모델링(디비 저장 구조로 변환)
- 데이터 모델 : 구조, 연산, 제약 조건을 표시
  - 개념적 데이터 모델 → E-R 모델, 논리적 데이터 모델 → 관계 데이터 모델, 물리적 데이터 모델
  - 개체, 속성, 관계(종속 관계, 중복 관계, 재귀 관계, 배타 관계)
  - 종속 관계 → 의존적인 객체는 약한 객체, 다른 개체의 존재 여부 결정하는 개체는 오너 객체
  - E-R 모델(개념적 데이터 모델) → 피터 첸 님이 제안.
    ![스크린샷 2023-07-21 02.41.20.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/958607e0-9baf-4bb9-8ecd-80d3f37643af/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-07-21_02.41.20.png)
- 관계형 데이터베이스 : 코드에 의해 제안
  - Relation → 데이터 표 형태로 표현.
  - Attribute → 열(필드)
  - Degree → 속성 개수
  - Tuple → 행(레코드)
  - Cardinality → 튜플 개수
  - Domain → 속성이 가질 수 있는 모든 값의 집합 (ex. 남, 여)
- Relation 특징 : 튜플의 유일성, 튜플의 무순서, 속성의 무순서, 속성의 원자성
- Key 종류
  - 후보키 → 튜플을 식별할 수 있는 속성들 부분집합, 유일성과 최소성 만족
  - 기본키 → 후보키 중 주된 키, 널값 안됨
  - 대체키 → 후보키 여러개일때 기본키 제외한 키들, 보조키
  - 슈퍼키 → 걍 속성들 집합. 유일성은 만족하나 최소성 만족 X
  - 외래키 → 다른 기본키 참조하는 속성 혹은 속성 집합
- 무결성
  - 개체 무결성 : 기본키를 구성하는 모든 속성은 Null 값 가질 수 없어
  - 참조 무결성 : 외래키는 참조할 수 없는 값을 가질 수 없어
- 관계 데이터 연산
  - 관계 대수 : 데이터 처리 과정 순서대로 기술. 절차적 언어
    - 순수 : `select` , `project` , `join` , `division`
    - 일반 : `union` , `intersection` , `difference` , `catesian product`
  - 관계 해석 : 처리를 원하는 데이터가 무엇인지만 기술 . 비절차적 언어

## 정규화

- 정규화(Normalization) : 이상 현상(데이터 조작 시 발생하는 부작용)을 제거하면서 데이터베이스를 올바르게 설계해나가는 과정
- 이상 현상(Anomaly)
  - 삽입 이상 : 새 데이터를 삽입하는데 기본키에 해당하는 데이터가 없음. 기본키에 null값을 넣을 수는 없으므로 삽입 불가
  - 갱신 이상 : 중복 튜플 중 일부만 변경해서 데이터가 불일치하게 되어 모순이 생기는 문제 발생
  - 삭제 이상 : 튜플을 삭제하면서 꼭 필요한 데이터도 같이 삭제되는 데이터 손실의 문제 발생
- 제 1정규형 : 모든 속성의 도메인이 원자 값으로만 구성되어 있는 정규형
  ![스크린샷 2023-07-21 03.02.08.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a27cc318-a474-4749-be11-fca850d7f56b/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-07-21_03.02.08.png)
  이벤트번호랑 당첨여부 안에 값이 여러개 들어가있으므로 1정규형 아님
- 제 2정규형 : 제 1정규형에 속하고, 기본키가 아닌 모든 속성이 기본키에 **완전 함수 종속**
  ![스크린샷 2023-07-21 03.04.51.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/404ec5b9-c5fc-4b07-a1b2-c2b13b2d5f6f/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-07-21_03.04.51.png)
  여기서 등급은 {고객 아이디, 이벤트 번호} 랑 {고객 아이디} 모두 종속이므로 부분 함수 종속임. 할인율도 마찬가지. 따라서 제2정규형으로 변환하려면 {고객아이디, 이벤트번호, 당첨여부}, {고객아이디, 등급, 할인율} 로 테이블을 쪼개면 된다.
- 제 3정규형 : 제 2정규형에 속하고, 기본키가 아닌 모든 속성이 기본키에 이행적 함수 종속이 되지 않아야 한다.
    <aside>
    💡 이행적 함수 종속(Transitive Functional Dependency) : X,Y,Z 집합에 대해 X→Y, Y→Z가 존재하면 논리적으로 X→Y가 성립하는데, 이를 속성 집합 Z가 속성 집합 X에 이행적으로 함수 종속되었다고 한다.
    
    </aside>
    
    ![스크린샷 2023-07-21 03.09.38.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/de74eb0b-4f91-40fd-9f42-bf2f18ba441c/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-07-21_03.09.38.png)
    
    {고객 아이디 → 등급} 이고 {등급 → 할인율} 이므로 할인율이 고객 아이디에 이행적으로 함수 종속 되어 있다. 따라서 이를 제3정규형으로 변환하려면 {고객아이디,등급}, {등급, 할인율} 로 쪼개면 된다.

- 보이스/코드 정규형(BCNF) : 릴레이션의 함수 종속 관계에서 모든 결정자가 후보키임. 후보키를 여러개 가지고 있는 릴레이션에서 발생할 수 있는 이상 현상을 해결하기 위해 제 3정규형보다 좀 더 엄격한 제약 조건을 제시하는 것임.
- 제 4정규형 : BCNF를 만족하면서, 함수 종속이 아닌 다치 종속을 제거하면 만족
- 제 5정규형 : 제4정규형을 만족하면서, 후보키를 통하지 않은 조인 종속을 제거해야 만족
- 반정규화 : 시스템 성능 향상과 운영 편의성을 위해 정규화된 데이터 모델을 통합, 중복, 분리하여 정규화 원칙을 위배하는 것

## 트랜잭션

- 트랜잭션 : 데이터베이스 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위, 한꺼번에 수행되어야하는 일련의 연산들
- ACID
  - 원자성(Atomicity) → 트랜잭션 연산이 디비에 모두 반영되도록 완료되던지 아님 복구하던지 둘 중 하나만 해야함
  - 일관성(Consistency) → 트랜잭션 연산이 완료되어도 언제나 일관성 있는 데이터베이스 상태로 변환해야함
  - 독립성(Isolation) → 둘 이상 트랜잭션이 동시에 병행되면 어느 하나의 트랜잭션 실행 중에 다른게 끼어 들면 안됨
  - 영속성(Durability) → 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나도 무조건 영구적으로 반영되어야 함
- 회복 : 디비를 모순이 없는 일관된 상태로 유지하기 위해 → 데이터를 별도의 장소에 미리 복사해두었다가 장애로 인해 문제 발생 시 이를 이용해 원래 상태로 복원하는 것
- 회복을 위한 복사본
  - 덤프 : 디비 전체를 다른 저장 장치에 주기적으로 복사하기
  - 로그 : 변경 연산이 실행될 때마다 변경 전/후 값을 별도의 파일에 기록하기
- 회복 연산 : redo, undo
- 로그 회복 기법
  - 즉시 갱신 기법 : 트랜잭션이 데이터 업데이트하면 부분 완료가 되기 전이더라도 일단 실제 디비에 반영하는 기법
  - 연기 갱신 기법 : 트랜잭션이 모두 완료될때까지 실질적인 디비 업데이트는 좀 연기하는 방법
- 그림자 페이지 대체 기법 (Shadow Paging)
- 검사점 기법 (Check Point)

## 병행 수행 및 제어

- 병행 수행 : concurrency. 여러 사용자들이 동시에 디비에 접근 가능 → 여러 트랜잭션이 동시에 수행
  - 갱신 분실 : 내가 수행한 결과를 남이 덮어 써서 변경 연산이 무효화됨
  - 모순성 : 한 트랜잭션에서 여러 개의 데이터를 변경할 건데, 일관성 없는 디비가 데이터를 다 다르게 줘서 연산 결과에 모순성이 생겨버리는 것
  - 연쇄 복귀 : 내가 트랜잭션 하다가 롤백했는데, 내가 장애 전에 변경했던 데이터를 가지고 연산 수행한 다른 트랜잭션도 연쇄적으로 롤백을 해야하는 상황이 생겨버리는 것
- 병행 제어 : 각 트랜잭션이 다른 트랜잭션의 방해를 받지 않고 정확한 수행 결과를 얻을 수 있도록 제어. 동시성 제어
  - Locking : lock, unlock → 트랜잭션이 동일한 데이터에 동시 접근 불가
  - 타임 스탬프 순서 : 트랜잭션에 시간표 부여하여 부여된 시간에 따라 트랜잭션 작업 수행

## 분산 데이터베이스

- 분산 데이터베이스 시스템 : 물리적으로 데이터베이스 시스템을 분리시키고, 이를 네트워크로 연결해 사용자는 논리적으로 하나의 중앙 집중식 시스템처럼 사용할 수 있도록 하는 것
- 분산 투명성 : 사용자는 데이터베이스가 물리적으로 분산되어 있는 걸 인식하지 못하게 하는 것이 중요
  - 위치 투명성 : 사용자는 실제 저장 위치 알 수 없어
  - 중복 투명성 : 데이터가 여러 군데에 중복되어 있더라도 사용자는 하나만 있는 줄 알아
  - 병행 투명성 : 다수의 트랜잭션이 동시에 실행되도 그 결과는 영향 받지 않아?
  - 장애 투명성 : 특정 지역에 문제 발생해도 전체 시스템엔 문제 없어
  - 단편화 투명성 : 하나의 릴레이션을 잘게 조개. 하지만 사용자는 그거 몰라

## 기타 용어

- Index : `<키, 값, 포인터>`
- View : 접근 허용된 자료만 보여주기 위해 만든 가상 테이블
- Cluster, Clustering : 동일한 성격의 데이터를 동일한 데이터 블록에 저장하는 물리적 저장 방법
- Partition : 대용량 테이블이나 인덱스를 작은 논리적 단위인 파티션으로 나눔
  - 범위 분할 : 열 값 기준(일별, 월별)
  - 해시 분할 : 해시 함수 적용
  - 조합 분할 : 범위 분할 → 해시 함수 적용
- RTO : Recovery Time Objective. 복구 후 가동까지 소요시간
- RPO : Recovery Point Objective. 데이터 복구할 수 있는 기준점
- 데이터베이스 이중화 : 동일한 데이터베이스 복제 후 관리
  - Eager : 데이터 변경 발생 시 즉시 전달
  - Lazy : 트랜잭션 모두 종료되면 그때 변경 사실을 전달
- 접근 통제
  - DAC : Discretionary. 임의 접근 통제. 사용자 신원에 따라 접근 권한 부여
  - MAC : Mandatory. 강제 접근 통제. 주체와 객체의 등급을 비교 후 접근 권한 부여
  - RBAC : Role Based. 역할 기반 접근 통제. 사용자 역할에 따라 접근 권한 부여
- Storage : 서바와 저장 장치를 연결
  - DAS : Direct Attached Storage. 전용 케이블로 연결
  - NAS : Network Attached Storage. 네트워크로 연결
  - SAN : Storage Area Network. DAS + NAS 혼합. 전용 네트워크 구성
- 트리거(Trigger) : 데이터베이스가 미리 정해놓은 조건이 충족되거나, 데이터 변경 이벤트가 발생하면 DBMS에서 자동으로 실행되도록 구현된 프로그램. 데이터 무결성 유지 및 로그 메세지 출력 등 별도 처리를 위해 사용

# 3. 네트워크

## Protocol

- 프로토콜 : 시스템이 데이터 교환을 위해 사용하는 통신 규칙
- 프로토콜 기본 요소 3가지
  - 구문 : 데이터의 형식, 부호화, 신호 레벨 등
  - 의미 : 두 기기간의 정확한 정보 전송을 위한 제어 정보 규정
  - 시간(타이밍) : 통신 속도, 순서 제어 등 규정
- 프로토콜 기능 : 단편화, 재결합, 캡슐화, 흐름제어, 오류제어, 순서 제어, 동기화, 다중화, 전송 서비스 등
- **TCP/IP (Transmission Control Protocol/Internet Protocol)**
  - TCP → 전송 계층. 신뢰성, 연결형. 패킷의 다중화, 순서 제어, 오류 제어 등 담당
  - IP → 네트워크 계층. 데이터그램 기반, 비연결형. 패킷의 분해 및 조립, 경로 선택 등
- 라우팅 프로토콜
  - IGP : Interior Gateway Protocol. 자율 시스템 내 라우팅에 사용되는 프로토콜
  - RIP : Routing Information Protocol. 거리 벡터 라우팅 프로코로톨. 최단 경로 계산
  - OSPF : Open Shortest Path First. 최적 경로 계산, RIP 단점 보완
  - EGP : Exterior Gateway Protocol. 자율 시스템 간의 라우팅.
  - BGP : Border Gateway Protocol : 자율 시스템 간의 라우팅. 서로 다른 조직의 네트워크를 연결할 때 사용. EGP 단점 보완

## OSI 7계층

![스크린샷 2023-07-21 04.21.05.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d8b354ae-5662-4256-8a49-e3ec5e6b6885/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-07-21_04.21.05.png)

<aside>
💡 하위 계층 : 물리, 데이터 링크, 네트워크 계층
상위 계층 : 전송, 세션, 표현, 응용 계층

</aside>

- 응용 계층(7) : 사용자가 응용 프로그램 사용 등 상호작용 **SMTP, HTTP, FTP, DHCP, SNMP**
- 표현 계층(6) : 통신에 적당한 형태로 데이터 변환 (암호화, 인코딩, 압축 등)
- 세션 계층(5) : 연결 생성, 유지, 종류 관리(일방적인지 쌍방인지 등)
- 전송 계층(4) : 논리적 안정과 균일한 데이터 전송 서비스 **TCP,UDP,PORT**
- 네트워크 계층(3) : 네트워크 연결, 데이터 교환, **라우팅. IP, ICMP, IGMP, ARP, RARP**
- 데이터 링크 계층(2) : 시스템 간 연결 설정 유지 및 종료 (흐름제어, 오류제어 등) **MAC**
  - L2TP : L2F + PPTP
- 물리 계층(1) : 0과 1 디지털 신호 → 전기 신호

<aside>
💡 응용 계층
- SMTP(Simple Mail Transfer Protocol) : 전자우편 전송
- HTTP(HyperText Transfer Protocol) : 웹 서버 및 브라우저 통신 
- FTP(File Transfer Protocol) : 파일 전송 
- TEINET : 남 컴퓨터를 내꺼처럼 
- DNS(Domain Name System) : 도메인 네임을 IP 주소로 매핑
- SNMP : TCP/IP 네트워크 관리 프로톸
- DHCP(Dynamic Host Configuration Protocol) : TCP/IP 기본설정 제공

</aside>

<aside>
💡 전송 계층 
- TCP : 연결 지향, 높은 신뢰성, 흐름 제어 및 혼잡 제어
- UDP : 비연결 방식, TCP 보다 속도 빠르지만 낮은 신뢰성 
- RTP : 실시간 멀티미이더 데이터 전송 (오디오, 비디오)

</aside>

<aside>
💡 인터넷 계층
- IP 
- ICMP : Internet Control Message Protocol. 통신 관련 제어 처리. IP 패킷을 처리할 때 발생하는 문제를 알려주는 프로토콜. 다른 호스트나 게이트웨이와 관련된 네트워크에 문제가 있는지 확인하기 위한 목적으로 사용된다. ICMP Flooding 공격은 ping 명령어를 통해 ICMP 패킷을 연속적으로 보내 다른 응답 작업을 하지 못하도록 막는 것. 
- IGMP : Internet Group Management Protocol : 멀티캐스트 그룹 유지 
- ARP : Address Resolution Protocol : ip 주소 → MAC 주소(물리적)
- RARP : Reserve Address Resolution Protocol : MAC 주소 → IP 주소

</aside>

- SSH : 다른 컴퓨터에 로그인, 원격 명령 실행, 파일 복사등을 수행할 수 있도록 다양한 기능을 지원하는 프로토콜. 강력한 암호화와 인증 방법으로 보안성이 낮은 네트워크에서도 사용 가능. 22번 포트 사용

## 정보 통신망

- 정보 통신망 : 정보를 효율적으로 전송하기 위해 통신 장비를 상호 유기적으로 결합
- 정보 통신망 구성 요소
  - 단말 장치 : ex. 컴퓨터
  - 통신 회선 : 데이터 전송하는 통로(전화선, 광섬유 케이블 등)
  - 교환기 : 단말 장치와 통신회선 연결하는 방식
    - 비교환회선 : 단말 장치끼리 직통회선
    - 교환회선 : 교환기 거침
- 네트워크 범위/연결 방식에 따라 → LAN. WAN. MAN. VAN
- 구성 형태에 따라 → 트리형, 버스형, 링형, 성형, 망형
- 교환 방식에 따라 → 회선 교환(ex. 전화), 축적 교환(메세지 교환 방식은 길이 변함. 패킷 교환 방식은 길이 고정 및 규격화)
  ![스크린샷 2023-07-21 04.30.42.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9c411948-d0f6-4006-8ee6-26ea26ed66a3/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-07-21_04.30.42.png)
  - 패킷 교환 방식
    - 데이터그램 방식(Datagram) : 데이터를 패킷 단위로 분할. 비연결 지향
    - 가상 회선 방식(Virtual Circuit, VC) : 가상회선 생성. 연결 지향.

## IP Address

- IPv4 → 유니캐스트, 멀티캐스트, 브로드캐스트
- IPv6
  - 유니캐스트 : 1:1 통신
  - 멀티캐스트 : 1:N 통신
  - 애니캐스트 : 1:1 통신 (가까이 있는 사람과)
- IP 주소 구성
  ![스크린샷 2023-07-21 04.46.13.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c973b964-9f35-4752-bc3d-084d632e9017/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-07-21_04.46.13.png)
  - 네트워크 IP가 같으면 같은 네트워크 상에서 자유롭게 통신 가능
- 클래스
  - A : 국가나 대형 통신망
  - B : 중대형 통신망
  - C : 소규모 통신망
  - D : 멀티캐스트(1:N)
  - E : 실험적 주소
- 서브넷 : 네트워크 영역을 부분적으로 나눠
- 서브넷 마스크 : Network ID와 Host ID를 분리
- 서브넷팅 : 할당된 네트워크 주소를 다시 여러개로 나눠

서브넷팅 할떄 문제,,,???

# 4. 웹

## 웹 주요 기술

- WWW : World Wide Web
- HTTP : HyperText Transfer Protocol. 웹 브라우저-서버 통신 프로토콜
- MIME : Multipurpose Internet Mail Extensions. 이메일에서 텍스트, 이미지 등 다양한 유형 파일 보낼 수 있게 해주는 표준화된 방식
- URL : Uniform Resource Locator. 특정 웹 페이지 위치 나타내는 문자열
- HTML : HyperText Markup Langauge. 웹 페이지 작성에 사용되는 마크업 언어

## 웹 표준 기술

- SOAP : Simple Object Access Protocol. 다른 컴퓨터의 데이터나 서비스를 호출하기 위한 통신규약. XML 기반 메세지 교환
- UDDI : Universal Description Discovery and Integration. 개방형 표준과 비독점적 기술 기반.. 이 덕분에 다양한 웹 사이트를 사용자가 쉽게 검색 가능
- WSDL : Web Services Description Langauge. 웹 서비스 기능을 외부에서 사용할 수 있도록 방법을 알려주는 언어로 XML 기반.
- XML : 다목적 마크업 언어
- XrML : 디지털 컨텐츠, 웹 서비스 권리 조건을 표현한 XML 기반 언어. eXtensible rights Markup Language
- AJAX : Asynchronous Javascript and XML. 비동기 작업 담당. Google 맵과 페이지에 사용한 기술에 기반하여 제작. SOAP이나 XML 기반의 웹 서비스 프로토콜이 사용됨
- JSON : Javascript Object Notation. 객체 표기 방법을 기반으로 한 데이터 방식

## 기타 용어

- EAI : Enterprise Application Integration. 각 플랫폼 및 애플리케이션들 간의 정보 전달, 연계, 통합 가능하게 해주는 솔루션. 송수신 시스템 어댑터 사용
  - Point to Point. Hub and Spoke. Message Bus(ESB). Hybrid
- SOA : 서비스 지향 아키텍처
- ISMS : Information Security Management System. 정부에서 정한 기관에서 주요 정보자산을 보호하기 위해 수립 및 운영하는 관리체계가 인증 기준에 적합한지 심사하여 인증을 부여하는 제도…

# 5. 보안

- 보안의 3대 요소
  - 기밀성(Confidentiality) : 인가된 사용자만 접근 가능
  - 무결성(Integrity) : 인가된 사용자만 수정 가능
  - 가용성(Availability) : 인가된 사용자는 언제나 사용 가능
- AAA
  - Authentication : 인증 → 자신의 신원을 시스템에 증명
  - Authorization : 권한 부여 → 인증이 수행된 객체에 대해 접근 권한 부여의 적절성 확인
  - Accounting : 계정 관리 → 접근 성공 객체에 대해 로그를 남김
- DOS(Denial of Service)
  - 취약점 공격형
    - Boink, Bonk, TearDrop 공격 : UDP, TCP 패킷의 시퀀스 넘버 조작하여 공격 시스템에 과부하 일으킴
    - LAND Attack : Local Area Network Denial Attack. 공격자가 패킷의 출발지 주소나 포트를 임의로 변경해 출발지와 목적지 주소를 동일하게 함으로써 공격 대상 컴퓨터 실행 속도를 느리게 하거나 동작을 마비시켜 서비스 거부 상태에 빠지게 하는 공격 방법
  - 자원 고갈 공격형
    - Ping of Death : 패킷 크기를 인터넷 프로토콜 허용 범위 이상으로 전송하여 공격 대상의 네트워크를 마비 시킴
    - SYN Flooding : SYN 패킷만 보내서 서버의 동시 가용 사용자 수를 점유하여 다른 사용자가 서버를 사용할 수 없게 막음
    - Smurf(Smurfing) : IP나 ICMP 특성을 악용하여 엄청난 양의 데이터를 한 사이트에 집중적으로 보냄으로써 네트워크를 불능 상태로 만듬
    - Mail Bomb : 스팸을 이용한 대량 메일
    - UDP Flooding : 대량의 UDP 패킷을 만들어 임의의 포트 번호로 전송하여 응답 메세지(ICMP Destination Unreachable)을 생성하게 하여 지속적으로 자원 고갈 시킴
  - DDoS(Distructed Denial of Service) : 광범위한 네트워크를 이용하여 다수의 공격 지점에서 동시에 한 곳을 공격

## 네트워크 보안

- 네트워크 침해 공격
  - APT(Advanced Persistent Threats) : 특정 기업이나 조직의 네트워크에 침투해 활동 거점을 마련한 뒤 때를 기다리면서 보안을 무력화시키고 정보를 수집한 후 외부로 빼돌리는 공격
  - 무작위 대입 공격(Brute Force Attack) : 암호화된 문서의 암호키를 찾아내기 위해 적용 가능한 모든 값을 대입하여 공격
  - 큐싱(Qshing) : QR코드 이용해서 악성 앱 및 프로그램 설치 유도
  - SQL Injection 공격 : 취약한 사이트 발견해서 디비 등 데이터 조작하는 공격 방식
  - XSS(Cross Site Scripting) : 스크립트 취약점 악용. 특정 링크 클릭시 악성 스크립트 실행
  - Sniffing(스니핑) : 네트워크 상에서 전송되는 데이터를 가로채서 엿보는 것
  - Spoofing(스푸핑) : 다른 사람으로 위장하여 정보를 송수신하는 것으로 IP 주소 변조 후 시스템에 접근
  - Session Hijacking : 세션 하이재킹. 인증된 사용자의 세션을 탈취하여 사용자의 권한 도용
  - Watering Hole Attack : 워터링 홀 공격. 타깃 삼은 특정 집단이 주로 방문하는 웹 사이트를 감염 시키고 피해 대상이 방문할때까지 기다리는 공격
  - Evil Twin : 이블 트윈. 와이파이 네트워크에서 공격자가 가짜 AP를 구축하고 강한 신호를 보내어 사용자가 가짜 AP에 접속하게 됨으로써 사용자 정보를 중간에서 가로채는 기법
- 사회 공학
  - Smishing : 스미싱. 문자 메세지 이용해 개인 신용 정보 빼내는 수법
  - Spear Phishing : 스피어 피싱. 일반적인 이메일을 위장한 메일을 지속적으로 발송하여 개인정보 탈취
  - Pharming : 파밍. 악성코드에 감염된 PC를 조작해. 피싱 사이트로 유도하여 금융정보 탈취
  - Whaling : 웨일링. 스피어 피싱의 한 종류로, 유명인 들을 타깃으로 한 공격
- 기타 용어
  - Zombie PC : 악성코드에 감염되어 다른 프로그램이나 컴퓨터를 조종하도록 만들어진 컴퓨터
  - C&C Server : 해커가 좀비 PC에 명령을 내리고 악성코드를 제어하기 위한 서버
  - Botnet : 봇넷. 악의적으로 사용되는 다수의 컴퓨터들이 네트워크로 연결된 상태
  - Crimeware : 온라인 상에서 불법 활동을 조장하기 위해 만들어진 프로그램. 공격용 툴킷
  - Worm : 네트워크를 통해 연속적으로 자신을 복제하여 시스템 부하를 높여서 결국 시스템을 다운시키는 바이러스의 일종
  - Zero Day Attack : 제로 데이 공격. 보안 취약점이 발견되었을 때 발견된 취약점이 널리 알려지기도 전에 해당 취약점을 이용해 이루어지는 보안 공격
  - Key Logger Attack : 키로거 공격. 키보드 움직임을 탐지해 개인 정보 빼내가는 해킹 공격
  - Ransomware : 랜섬웨어. 사용자의 컴퓨터에 잠입해 내부 문서 등을 암호화해 열지 못하게 하는 프로그램. 암호 해독용 프로그램을 조건으로 돈 요구하기도 함.
  - Back Door, Trap Door : 백도어. 개발자들의 액세스 편의를 위해 보안을 제거하여 만들어놓은 비밀 통로로, 범죄에도 악용됨
  - Trojan Horse : 트로이 목마. 정상 프로그램으로 위장하여 프로그램 내에 숨어있다가 해당 프로그램이 동작할때 활성화되어 부작용 일으키는 것.
  - Credential Stuffing : 크리덴셜 스터핑. 확보한 크리덴셜(개인 정보)를 다른 계정에 마구 대입하여 이용자 정보를 침해
  - Island Hopping : 아일랜드 호핑. 한 조직을 공격해 해당 조직의 고객, 파트너사 등도 차례차례 공략하는 것
  - Supply Chain Attack : 공급망에 침투하여 악성코드 배포. 선의의 소프트웨어를 통해 이용자들 공격
  - Drive-by Download : 의도치 않은 상황에서 사용자도 모르게 악성코드 다운
  - 버퍼 오버플로우 : 정해진 메모리의 범위를 넘치게 해서 원래의 리턴 주소를 변경시킴
  - CSRF : Cross Site Request Forgery. 사용자가 자신의 의지와 무관하게 공격자가 의도한 행동을 해서 특정 웹사이트를 보안에 취약하게 한다거나 특정 작업을 하게 만듦
  - HoneyPot : 허니팟. 가상의 정보시스템을 만들어 놓고 실제로 공격을 당하는 것처럼 보이게 하여 해커, 스팸, 바이러스 유인 후 침입자들 정보 수집
  - RUDY : R-U-Dead-Yest, Content-length를 비정상적으로 크게 설정하여 메세지 바디 부분을 매우 소량으로 보내 계속 연결 상태를 유지시킴

## 암호 알고리즘

![스크린샷 2023-07-21 05.00.49.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bdb39013-bbff-468e-b5d8-35c1fa78cabb/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-07-21_05.00.49.png)

- 개인키 : 동일한 키로 암호화 및 복호화
  - 스트림 암호화 방식 : 평문과 동일한 길이의 스트림 생성 **LFSR, RC4**
  - 블록 암호화 방식 : 한번에 하나의 데이터 블록 암호화 **DES, SEED, AES, ARIA**
- 공개키 : 암호화할때 키는 사용자에게 공개, 복화할때 키는 관리자가 비밀리에 관리
- SEED
- DES : Data Encryption Standard
- AES : Advanced Encryption Standard
- ARIA : Academy, Research Institute, Agency
- RSA : Riverst Sharmir Adleman
- IDEA : International Data Encryption Standard. 국제 데이터 암호화 알고리즘. 64비트 블록을 128 비트의 키를 이용하여 8개의 라운드 구성
- Skipjack : NSA에서 개발한 칩에 내장되어있는 블록 알고리즘. 전화기와 같은 음성을 암호화

## 해시

- SHA
- MD5
- N-NASH
- SNEFRU

## 보안 솔루션

- SSO : Single Sign On
- Firewall
- IDS : Intrusion Detection System
- IPS : Intrusion Prevention System
- DLP : Data Leakage/Loss Prevention
- VPN : Virtual Private Network
- NAC : Network Access Control
- ESM : Enterprise Security Management
- SIEM : Security information and Event Management
- SOAR : Security Orchestration Automation and Response

# 6. 운영체제

- UNIX
  - 커널 : 프로그램과 하드웨어 간의 인터페이스 담당
  - 쉘 : 시스템과 사용자 간의 인터페이스 담당
- 운영체제 목적 → 처리 능력 향상, 사용 가능도 향상, 신뢰도 향상, 반환 시간 단축
- 주기억장치 관리 → 반입 전략, 배치 전략, 교체 전략
- 반입 전략 : 언제 데이터를 주기억장치로 적재할지
  - 요구 반입 : 데이터 참조를 요구할 때
  - 예상 반입 : 참조될 데이터 미리 예상해서
- 배치 전략 : 데이터를 주기억장치의 어디에 위치시킬지
  - 최초 적합 : 걍 첫번째 분할 영역에 배치
  - 최적 적합 : 빈 영역 중 단편화를 가장 적게 남기는 영역에 배치
  - 최악 적합 : 단편화를 가장 많이 남기는 영역에 배치
- 가상 메모리 → 페이징 기법, 세그멘테이션 기법
  - Locality(국부성, 지역성, 구역성, 국소성) : 일부 페이지만 집중적으로 참조한다는 성질
  - Working Set : 자주 참조하는 페이지의 집합. 데닝
  - Thrashing(스레싱) : 프로세스 처리 시간보다 페이지 교체가 더 오래걸리는 현상
- 교체 전략 : 주기억 장치의 모든 영역이 이미 사용중일때 어떤 영역을 교체할지 결정
  - OPT : Optimal Replacement. 앞으로 오래 사용하지 않을 페이지 교체. 가장 이상적
  - FIFO : First In First Out. 가장 먼저 들어왔던 페이지를 교체
  - LRU : Least Recently Used. 가장 오랫동안 사용하지 않은 페이지를 교체
  - LFU : Least Frequently Used. 사용 빈도가 가장 적은 페이지 교체
  - NUR : Not Used Recently. 최근에 사용하지 않은 페이지.두개비트 사용
  - SCR : Second Chance Replacement. 가장 오랫동안 있었던 페이지 중 자주 사용되는 페이지 교체를 방지
- 스케줄링 : 여러개의 프로세스를 CPU에서 실행되는 순서 결정
  - 비선점 스케줄링 : Non-Preemptive. 이미 할당된 CPU를 다른 프로세스가 강제로 뺏을 수 없음. FCFS, SJF, 우선순위, HRN, 기한부 등
  - 선점 스케줄링 : 강제로 빼앗아 쓸 수 있음. RR, SRT, 다단계 큐 등
  - FCFS → 큐에 도착한 순서에 따라 차례로 할당
  - SJF → Shortest Job First. 실행 시간 짧은 프로세스에게 먼저 할당
  - HRN → Hightest Response-ratio Next. `(대기시간+서비스시간) / 서비스시간`
  - RR → Round Robin. 순서대로 시간 단위로 CPU 할당. 사용할 수 있는 최대시간 있음.
  - SRT : Shortest Remaining Time. SJF를 선점 스케줄링 방식으로 변경. 최단 잔여시간 우선
- Dead Lock
  - 프로세스들이 모두 작업 수행 못하고 대기 상태에 놓인 상태
  - 발생 조건 → 상호 배제, 점유와 대기, 비선점, 환형 대기
  - 해결 방법 → 예방 기법, 회피 기법, 발견 기법, 회복 기법

# 7. 자료구조
