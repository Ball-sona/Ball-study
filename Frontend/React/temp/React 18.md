# What's New in React 18

https://react.dev/blog/2022/03/29/react-v18

## Automatic Batching

## Transitions

## New Suspense Features

## New Client and Server Rendering APIs

## New Strict Mode Behaviors

## New Hooks



<hr />

## Virtual DOM

### Dom tree

- HTML Element
- tree 형태

### Virtual DOM

- 실제 DOM과 같은 내용을 담고 있는 복사본. -> 메모리에 저장되어 있는 자바스크립트 객체임
- 이를 통해 브라우저 문서에 직접적으로 접근 및 수정할 수 없다. 
- 그럼 왜 사용하나? -> 실제 DOM을 조작하는 시간을 단축시키기 위해.

### 가상돔 동작 방식

일단, 리액트는 항상 2개의 가상돔 객체를 가지고 있다는 것을 기억하자.

- 렌더링 이전 화면 구조를 나타내는 가상돔
- 렌더링 이후에 보일 화면 구조를 나타내는 가상돔

다음은 동작 과정이다.

1. Rendering: 화면에 실제 DOM 그려준다.
2. Re-rendering: 리액트 상태값이 변경되면 리렌더링 발생. -> 새로운 내용이 담긴 가상돔을 생성한다.
3. Diffing: 렌더링 이전 화면 구조를 담은 가상돔과 업데이트 이후 생성할 두번째 가상돔을 비교해서 어떤 element 가 변했는지 비교
4. Reconciliation: 차이가 발생한 부분만 실제 DOM에 적용한다. 이때 변경된 모든 element들을 집단화시켜서 한번에 실제 DOM에 적용하는 'Batch Update' 덕에 이 과정이 매우 효율적이다. 

## Rendering

렌더링은 리액트가 컴포넌트들에게 현재 props와 state에 기반해서 화면에 뭘 보여주고 싶은지 알려달라고 요청하는 과정이다.

렌더링은 리액트가 DOM에 변화를 줘야할지 여부를 파악하기 위해 각 컴포넌트들이 props, state를 기반해서 업데이트를 해야하는지 파악하는 과정이다.

### 렌더링 과정

1. 컴포넌트 트리 루트에서부터 시작해서 아래쪽으로 순환하며 컴포넌트 찾기
2. 컴포넌트 찾으면 종류에 맞게 함수 호출.
   - 클래스형 컴포넌트는 `classComponentInstance.render()`
   - 함수형 컴포넌트는 `FunctionComponent()`

3. 컴포넌트 함수의 반환값 jsx 구문은 js가 컴파일되고 배포 준비되는 시점에 `React.createElemnt()`  호출로 변환
4. 이렇게 결과물 모두 수집하고나면. 새로운 객체 트리와 비교하고 변경사항 수집 -> Reconciliation
5. 계산된 모든 변경 사항을 하나의 <u>동기적 시퀀스</u>로 실제 돔에 적용 
6. 실제돔 업데이트 이후. `componentDidMount`, `componentDidUpdate`, `useLayoutEffect` 훅을 동기적으로 실행 
7. 짧은 타임 아웃 이후. `useEffect` 실행-> passive effect

> lazy function.. 

> conccurent mode..

### 렌더와 커밋 

위 과정을 크게 2단계로 나눌 수 있다.

1. 렌더 단계 -> 렌더링하고. 변경 사항 계산하고. ..
2. 커밋 단계 -> 변경 사항 실제 돔에 적용 

### 렌더링 규칙 

> [The Rules of React](https://gist.github.com/sebmarkbage/75f0838967cd003cd7f9ab938eb1958f)

렌더링은 '순수'해야한다. 즉, 사이드 이펙트를 만들어내서는 안된다. 

### 리렌더링 로직 

diffing, reconciliation

1. 어떻게든 기존 컴포넌트 트리와 돔구조를 최대한 재활용하려고 한다.  즉, 만약 같은 컴포넌트를 렌더링하라는 요청이 들어오면 리액트는 그 컴포넌트 인스턴스를 그대로 유지한다.
2. 엘리먼트의 type 필드를 기반으로 비교한다. 만약 `<div> vs <span>` or `<Comp1> vs <Comp2>` 처럼 엘리먼트 타입이 다르면. 전체 트리가 변경되었다고 가정하고 현재 존재하는 모든 트리를 파괴한 후에 새로운 컴포넌트 인스턴스로 만들어나간다. 
3. 컴포넌트 유형의 특정 인스턴스를 식별하기 위한 고유 식별자. `key` 를 사용한다.

> 왜 리액트에서 key에 인덱스를 넣으면 안되는지

## Batching

- setState가 호출되면. 새로운 렌더링 패스가 시작되고. 동기적으로 실행되고 결과값 반환
- 여러개의 setState가 호출되면. 이 렌더링 패스들이 대기열에 저장이 되었다가 실행됨. -> 렌더링 배치 
- 개별 setState에 의한 렌더링은 동기적으로 동작하지만. 리액트가 내부적으로 다수의 setState를 묶었다가 일괄처리 하기 때문에. 대기하게 되는 렌더링들은 비동기적으로 실행되는 것.
- `unstable_batchedUpdates` 함수가 모든 상태 업데이트를 추적. 단일 렌더링 패스에 모두 적용.

## Fibers

- 모든 <u>컴포넌트 인스턴스를 추적하는 내부 자료 구조</u>를 갖고 있고, 이 중 핵심 부분이 'Fiber' 라는 객체다.
- 피버에는 메타데이터 필드가 들어가 있다.
  - 현재 렌더링되어야하는 컴포넌트 유형 = type
  - 해당 컴포넌트와 관련된 props, state
  - 부모, 형재, 자식 컴포넌트를 향한 <u>포인터</u>
  - 렌더링 과정을 추적하기 위해 필요한 다른 내부 데이터
- 리액트가 처음 렌더링할때 이 피버 객체를 생성. 
- `YourComponentType(props)` 를 호출하여 컴포넌트 인스턴스를 피버 객체에 저장.
- 이 피버 객체의 트리를 순환하며. 렌더링 결과물 계산해서. 업데이트된 트리 생성할 것. 
- 컴포넌트에서 쓰는 모든 훅을. 컴포넌트 피버 객체와 연결된 연결 리스트로 만들어 저장. 

## 렌더링 최적화

컴포넌트 렌더링을 생략하도록 하는 API

1. `shouldComponentUpdate` : 렌더링 과정 초반에 호출되는데. 만약 false 반환하면 렌더링 건너뛴다
2. `React.PureComponent` : `shouldComponentUpdate` 탑재한 컴포넌트
3. `React.memo()` : 컴포넌트 타입을 인수로 받고. 새로운 래퍼 컴포넌트를 반환. 래퍼 컴포넌트는 props가 변경되었는지 여부 체크하고. 변경 안되었으면 리렌더링 막아. 

렌더링 결과물을 이전에 반환했던 결과물과 동일하게 만드는 방법

1. `props.children` 는 매번 다른 참조값을 가지니까 .. ?
2. `useMemo` 로 감싼 엘리먼트는 의존성값 변경되기까지 항상 동일.

### props 참조 최적화

부모 컴포넌트가 렌더링되면 자식 컴포넌트는 props변경 여부랑 상관없이 무조건 리렌더링된다. 근데 최적화를 위해. 자식 컴포넌트 props가 변경될때만 렌더링되도록 하고싶다! 그렇다면 메모이제이션 사용 

부모 컴포넌트 내에 있는같은 참조를 재사용하도록. 

- useMemo
- useCallback

### 메모이제이션 언제?

- 자식에서 변화를 일으키는 친구들에게만... ??
- 하지만. 메모이제이션은 `props` 비교하는 비용이 발생한다. 그래서 항상 새로운 props를 받아 어짜피 계속 리렌더링되는 컴포넌트는. 비용낭비인 것

## 훅 동작 방식

- 피버 객체와 연결된 연결 리스트에 훅을 모두 저장.
- 

