# Rendering

1. DOM
2. browser rendering vs react rendering
3. virtual DOM
4. Fiber

## 브라우저의 렌더링 

리플로우. 리페인트

## 리액트 렌더링의 탄생 배경

- 사용자 인터렉션에 의해 웹 페이지가 변경되는 상황이 늘어나면서, 브라우저의 DOM의 모든 변경 사항을 추적하고 관리해야 하는 부담이 늘어났다. 
- 페이지가 변경되는 경우 새로운 HTML을 받아 렌더링 과정을 다시 시작하는 일반적인 웹 사이트와 다르게, SPA는 하나의 페이지에서 계속해서 DOM 노드의 위치를 재계산하게 되므로 이러한 부담과 비용은 더 커진다.
- 따라서 이러한 문제들을 해결하기 위해 리액트는 '가상 DOM' 기법을 제안했다.

### 가상 DOM

- 가상 DOM은 실제 브라우저의 DOM이 아닌 리액트가 관리하는 가상의 DOM으로, **웹 페이지가 표시해야 할 DOM을 일단 메모리에 저장**하고 리액트가 실제 변경에 대한 준비가 완료되었을 때 실제 브라우저의 DOM에 반영한다. 
- 즉 DOM 계산을 브라우저가 아닌 메모리에 부담하여, 브라우저의 렌더링 과정과 비용 부담을 최소화한다.

- 리플로우, 리페인트를 반복적으로 하지않고. 한번에 묶어서 돔에 전달.

### Fiber

- 가상 DOM을 위한 아키텍처, [Fiber]()

## 리액트의 렌더링

- Fiber 

## 리액트 렌더링이 일어나는 이유

### 최초 렌더링

사용자가 애플리케이션에 처음 진입하면.

### 리렌더링

1. 클래스 컴포넌트인 경우. `setState` 실행된 경우
2. 클래스 컴포넌트인 경우. `forceUpdate` 실행된 경우
3. 함수형 컴포넌트. `useState` 의 두번째 배열 요소인 `setter` 실행된 경우
4. 함수형 컴포넌트. `useReducer` 의 두번째 배열 요소 `dispatch` 실행된 경우
5. 컴포넌트의 `key` 를 포함한 `props` 가 변경된 경우 -> 자식 컴포넌트 리렌더링
6. 부모 컴포넌트가 리렌더링된 경우 -> 자식 컴포넌트 리렌더링

## 렌더링 프로세스

컴포넌트 결과물 수집 -> 돔 비교해서 변경 사항 수집 -> 변경 사항을 돔에 적용

### 1. Render 단계

- 컴포넌트 실행. 변경사항 계산

### 2. 커밋 단계

- 렌더 단계에서 계산한 변경 사항을 실제 돔에 적용 
- 만약 렌더 단계에서 변경 사항 없었다면. 커밋 단계 생략된다. 즉, 렌더링이 일어난다고 해서 무조건 돔 업데이트가 발생하는 건 아니라는 것!

### 3. 커밋 이후

- 모든 돔 노드 및 인스턴스를 가리키도록 내부 참조 업데이트.
- 생명주기 메서드 및 useLayoutEffect 훅 호출

