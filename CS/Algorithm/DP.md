# Dynamic Programming

동적 계획법(다이나믹 프로그래밍)는 **큰 문제를 작게 나누고, 같은 문제라면 한 번씩만 풀어**서 문제를 효율적으로 해결하는 알고리즘 기법이다.

## 피보나치 수열

다이나믹 프로그래밍으로 해결할 수 있는 대표적인 예시로 '피보나치 수열'이 있다. 이는 이전 두항의 합을 현재의 항으로 설정하는 특징이 있는 수열이다.

<img width="586" alt="스크린샷 2023-03-07 13 25 51" src="https://user-images.githubusercontent.com/67703882/223320498-cd806197-e69f-43b1-b34f-e4aa6f97b0c4.png">

이는 점화식(인접한 항들 사이의 관계식)으로 간결하게 표현할 수 있다.

```
f(1) = 1; f(2) = 1;
f(n) = f(n-1) + f(n-2);
```

이러한 점화식에 따라서 실제로 피보나치 수를 구하는 과정을 어떻게 표현할 수 있을까?

<img width="195" alt="스크린샷 2023-03-07 13 27 43" src="https://user-images.githubusercontent.com/67703882/223320745-d810d03e-b51f-485e-9c17-52fb3b8233fe.png">

f(4)를 구한다고 한다면, 위 그림과 같이 함수 f를 반복해서 호출하면 된다. 이때 f(1), f(2)는 항상 1이기 때문에, 이 둘을 만났을 때는 호출을 정지한다. 이를 재귀함수로 사용하면 간단하게 구현할 수 있다.

```js
function fibo(x) {
  if (x === 1 || x === 2) return 1;
  return fibo(x - 1) + fibo(x - 2);
}
```

그러나 이러한 방식으로 구현하게 되면, x가 커질수록 수행 시간이 기하 급수적으로 늘어난다. 시간 복잡도는 $O(2^N)$ 가 된다.

이는 동일한 함수가 반복적으로 호출되기 때문이다. f(6)을 구하는데에도 f(3 ) 연산을 총 3번 하게 된다. 이는 x가 커질수록 반복 호출 수가 더 늘어난다.

이를 다이나믹 프로그래밍을 통해 해결할 수 있을까? **다이나믹 프로그래밍을 사용할 수 있는 조건**은 다음과 같다.

1. 큰 문제를 작은 문제로 나눌 수 있다.
2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.

피보나치 수열은 이러한 조건을 만족하는 대표 문제이다. 이를 메모이제이션 기법을 사용해서 해결해보자.

## 메모이제이션

메모이제이션은 다이나믹 프로그래밍을 구현하는 방법 중 한 종류로, 한 번 구한 결과를 메모리 공간에 메모해두고 같은 식을 다시 호출하면 메모한 결과를 그대로 가져오는 기법을 의미한다. 이를 캐싱이라고도 한다.

이러한 기법을 피보나치 수열에 적용하면 코드는 다음과 같다.

```js
const d = new Array(100).fill(0);

function fibo(x) {
  // 종료
  if (x === 1 || x === 2) return 1;
  // 이미 계산한 적 있다면
  if (d[x] !== 0) return d[x];
  // 이미 계산한 적 없다면
  d[x] = fibo(x - 1) + fibo(x - 2);
  return d[x];
}
```

이렇게 다이나믹 프로그래밍을 적용했을 때 피보나치 수열 알고리즘의 시간 복잡도는 $O(N)$ 이다. 한 번 구한 결과는 다시 구해지지 않기 때문이다.

## 탑다운 방식과 보텀업 방식

- Top-Down 방식(하향식)
  - 큰 문제를 해결하기 위한 작은 문제를 호출
  - 메모이제이션 기법
- Bottom-Up 방식(상향식)
  - 반복문을 이용해 작은 문제부터 차근차근 답을 도출
  - 다이나믹 프로그래밍의 전형적인 형태
  - 해당 방식에서 사용되는 결과 저장용 리스트는 'DP 테이블'이라고 한다.

## DP 풀이시..

- 문제가 DP를 사용하면 풀리는 문제인지 판단하자. 일반적으로 특정 수량의 최대/최소를 구하는 문제들이나 특정 조건을 만족하는 배열 개수를 세는 문제, 특정 확률 문제 등은 DP를 사용하여 해결할 수 있다.
- 상태 관계, 즉 점화식을 최대한 수식화해보자.
