# Chapter 13. 렌더링 패턴

- 컨텐츠를 어디서 어떻게 렌더링할 것인가?
  - 웹 서버, 빌드 서버, 엣지 네트워크, 클라이언트
- 컨텐츠를 한 번에, 부분적으로, 또는 점진적으로 어떻게 렌더링할 것인가?

## 렌더링 패턴의 중요성

- 적합한 렌더링 패턴을 선택하는 것은 DX와 UX에 있어서 굉장히 중요
- 올바른 패턴을 선택하면 더 빠른 빌드 속도와 탁월한 로딩 성능을 낮은 처리 비용으로 얻을 수 있음.
- CWV 같은 사용자 중심 지표를 기준으로 애플리케이션 최적화해야함.

### UX 관점

CWV(Core Web Vitals) 지표는 사용자 경험과 가장 관련 높은 요소들을 측정한다. 이를 기준으로 최적화하면 뛰어난 UX와 SEO를 보장할 수 있다.

- TTFB(Time to First Byte): 클라이언트가 컨텐츠의 첫번째 바이트를 받는데 걸리는 시간
- FCP(First Contentful Paint): 페이지 이동 후 브라우저가 컨텐츠의 첫 부분을 렌더링하는 데 걸리는 시간
- TTI(Time to Interactive): 페이지 로드 시작부터 사용자 입력에 반응할 수 있을 때까지 걸리는 시간
- LCP(Largest Contentful Paint)
- CLS(Cumulative Layout Shift): 예상치 못한 레이아웃 변경 방지를 위한 시각적 안정성
- FID(First Input Delay): 사용자가 페이지와 상호작용한 시점부터 이벤트 핸들러 실행될 수 있는 시점까지의 시간

### DX 관점

- 빠른 빌드 시간
- 낮은 서버 비용
- 동적인 컨텐츠
- 쉬운 롤백
- 안정적인 가동 시간
- 확장 가능한 인프라

## CSR(Client Side Rendering)

- 대부분의 애플리케이션 로직이 클라이언트에서 실행되고, 데이터를 가져오거나 저장하기 위해 API 호출로 서버와 상호작용
- 페이지 이동하면 페이지 렌더링을 위해 서버에 새로운 요청을 보내는게 아니라 자바스크립트 코드로 뷰나 데이터를 갈아끼우는 방식
  - 페이지 새로고침이 없이 이동 가능한 SPA 구축
- React, Vue, Angular

### 장단점

- 페이지 간 라우팅 빠르고, 뛰어난 반응성
- 페이지의 복잡성이 증가할수록 자바스크립트 코드의 복잡성 크기가 증가하게 됨.
  - 큰 자바스크립트 번들은 FCP와 TTI를 증가시킴.
- SEO에 취약

## SSR(Server Side Rendering)

- 사용자 요청에 대한 응답으로 렌더링할 페이지 컨텐츠의 전체 HTML을 서버에서 생성
- 쿠키 정보 등 기반으로 개인 맞춤형 데이터를 포함하는 페이지거나 인증 상태에 따라 렌더링 여부 결정해야 하는 페이지에 적합
  - ex. 대시보드 페이지
- HTML을 서버에서 렌더링하고 클라이언트에서 다시 하이드레이션하는 데 필요한 자바스크립트를 함께 제공
  - 즉 서버에서 한번 렌더링하고 클라이언트 사이드에서 UI 컴포넌트 상태를 재생성하는 과정
- Next.js

## Static Rendering

- 전체 페이지의 HTML을 빌드 시점에 미리 생성해놓는 방식
- CDN이나 엣지 네트워크에 쉽게 캐싱 가능 -> 더 빠르게 HTML 제공 가능
- 데이터가 자주 변경되지 않고 누가 요청하든 동일한 데이터를 표시하는 페이지에 적합
  - ex. 회사 소개 페이지, 블로그, 상품 페이지 등
- Next.js, Gatsby, VuePress

### 변형

## ISR(Incremental Static Regeneration)

- 특정 정적 페이지만 미리 렌더링해놓고, 동적 페이지는 사용자 요청 시 on-demand 방식으로 렌더링
  - 빌드 시간 단축
- 각 페이지에 적절한 타임아웃을 정의하고, 시간 경과할 때마다 페이지가 다시 유효한지 검증한다.
  - 타임아웃은 최소 1초까지
- 재검증이 완료될때까지는 캐시된 혹은 이전 버전의 페이지를 보여주다가, 완료되면 새로운 버전의 페이지를 보여준다.
  - 재검증은 백그라운드에서 이루어지기 때문에 재빌드 필요하지 X
  - Stale-While-Revalidate 전략
- 페이지는 사용자의 요청을 처리한 '엣지 네트워크 노드'에만 캐시된다.

## On-demand ISR

- 일반 ISR과 달리 정해진 시간 가격이 아니라, '특정 이벤트 발생 시' 페이지가 재생성된다.
- 일반 ISR과 달리 '엣지 네트워크 전체'에 페이지를 다시 생성하고 재분배
  - 자동으로 전 세계 사용자가 최신 버전의 페이지를 볼 수 있음.
- 불필요한 페이지 재생성과 서버리스 함수 호출을 피할 수 있어 운영 비용 절감 -> ???

## Streaming SSR

- 서버에서 하나의 HTML 파일을 보내는게 아니라, chunk 단위로 나눠서 스트리밍 방식으로 전송
- 클라이언트는 chunk 받는 즉시 컨텐츠 렌더링을 시작
- SSR 하면서도 TTI와 FCP 단축 가능

### 구현

- `renderToNodeStream`
- `renderToStaticNodeStream `

## Edge SSR

- 사용자와 가까운 곳에 위치한 엣지 노드에서 렌더링에 필요한 데이터를 제공하는 방식

## Hybrid Rendering

- 정적인 페이지는 서버에서 미리 렌더링하고, 이외 페이지들은 ISR, SSR, CSR 등 동적인 전략을 선택
- 더이상 웹 애플리케이션은 SPA, MPA 등으로 분류되지 않고, 각 페이지에 맞는 렌더링 모드를 유연하게 사용
- 여러 프레임워크가 하이브리드 렌더링을 지원
  - Next.js(RSC + App Router), Astro, Angular Universal, Nuxt

## Increnmental Hydration

- 각 노드를 개별적으로 시간에 따라 하이드레이션해서 필요한 '최소한의 자바스크립트만' 요청하는 방식
- 사용자에게 덜 중요한 부분은 하이드레이션을 좀 나중에 해서 상호작용을 지연시킴
- SSR에서 흔히 발생하는 서버에서 렌더링된 DOM 트리가 파괴되고 즉시 다시 생성되는 문제를 방지?

### 리액트의 동시성 모드

- 동시성 모드는 여러 작업을 동시에 처리하면서도 우선순위에 따라 작업 간 전환을 가능하게 함
- 페이지의 각 조각을 하이드레이션하는 작업을 동시성 모드에 맡기게 되면, 하이드레이션하다가 사용자 입력 들어오면 이를 일시중지하고 입력 처리하도록 전환 가능
- lazy, Suspense 통해 로딩 상태를 보여줄 수 있음

## Islands Architecture

- 컴포넌트 기반 아키텍처로, 정적/동적인 아일랜드로 구분된 페이지 뷰 제안
- 페이지 내 정적인 컨텐츠는 그냥 HTML 파일로 하이드레이션 필요없지만, 동적인 컨텐츠는 자바스크립트 로드되어 렌더링된 후 '스스로' 하이드레이션할 수 있는 능력 갖춤
  - 각 컴포넌트가 <b>자체적인 하이드레이션 스크립트</b>를 가지고 있는 게 점진적 하이드레이션과의 차이

## RSC(React Server Components)

- 리액트 서버 컴포넌트
