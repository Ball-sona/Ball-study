# 2주차 발표 - 믹스인 패턴

<p align="center">
<!-- <img src="https://github.com/user-attachments/assets/85f5b007-c7ab-473a-800d-7fa86552b96c" width="40%" > -->
</p>

- 믹스인 = 상속 없이 어떤 객체나 클래스에 재사용 가능한 '기능을 추가'할 수 있는 객체
  - 믹스인 용어 자체는 객체 지향 언어에서 범용적으로 사용됨
  - 다중 상속을 지원하지 않는 자바스크립트에서는 객체 지향에 대한 탈출구로 많이 사용되었었음

```js
// 동적으로 부모 클래스를 받아 확장하는 함수
const MyMixins = (superClass) =>
  class extends superClass {
    moveUp() {}
    moveDown() {}
  };

class CarAnimator {
  moveLeft() {}
}

// CarAnimator 확장
class MyAnimators extends MyMixins(CarAnimator) {}
const myAnimator = new MyAnimators();

myAnimator.moveLeft();
myAnimator.moveUp();
```

## Mixin vs 상속

- 믹스인이나 상속이나 어떤 공통 요소를 생성하고, 이를 확장할 수 있는 개별 요소들을 만드는 건 비슷한 개념
- https://velog.io/@ollehvelog/%EA%B9%80%EB%AF%BC%ED%83%9C%EC%9D%98-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EC%95%84%EC%B9%B4%EB%8D%B0%EB%AF%B8-5-%EC%83%81%EC%86%8D%EA%B3%BC-%EB%AF%B9%EC%8A%A4%EC%9D%B8#%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-%EB%AF%B9%EC%8A%A4%EC%9D%B8-%EC%A0%95%EB%A6%AC%ED%95%98%EB%A9%B4
- https://www.youtube.com/watch?v=Q5wnVJXt8mA

## Mixin vs HOC

- 믹스인은 객체지향 언어에서 사용되는 용어
- 리액트에서는 ES6 없던 시절 mixin 기능을 지원했었음. 그러나 코드와 의존성 관리의 복잡성을 매우 증가시키기 때문에 더이상 지원/권장 X
  - https://legacy.reactjs.org/blog/2016/07/13/mixins-considered-harmful.html

```js
const SetIntervalMixins = {
  // setInterval 관련 기능 제공

  setInterval() {},
};

const ClockComponent = React.createClass({
  mixins: [SetIntervalMixins], // mixin 사용

  componentDidMount() {
    this.setInterval();
  },
});
```

- HOC: 컴포넌트 래핑해서 추가 기능이나 로직 제공하는 고차 컴포넌트
  - 리액트 진영 + 함수형 프로그래밍에서 비롯된 패턴

```js
function withExtraProps(WrappedComponent) {
  return function EnhancedComponent(props) {
    return <WrappedComponent {...props} extraProp="I am extra!" />;
  };
}

const EnhancedComponent = withExtraProps(MyComponent);
```
