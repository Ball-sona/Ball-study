# Synchronization

## Synchronization

프로세스가 병행 또는 병렬로 실행될 때 여러 프로세스가 공유하는 데이터의 무결성에 어떤 문제를 일으키는 지 살펴보고, 이러한 문제를 해결하는 방법에 대해 알아보자.

### Race Condition

동시에 여러 개의 프로세스가 동일한 자료를 접근하여 조작하고, 그 실행 결과가 접근이 발생한 특정 순서에 의존하는 상황을 Race Condition이라고 한다. 우리는 프로세스의 수행 순서를 정확히 예측할 수 없기 때문에 이러한 순서에 데이터 값이 의존하게 된다는 것은 '데이터 일관성'을 보장하는 데 있어서 굉장히 위험한 상황이다. 

따라서 우리는 **데이터 일관성을 유지**하기 위해 한 순간에 하나의 프로세스만이 공유 데이터를 조작할 수 있도록, 즉 프로세스들이 순차적으로 수행할 수 있도록 프로세스 간 **동기화 작업**을 해주어야 한다.

## Critical Section

프로세스 동기화를 위해 우리는 각 프로세스의 특정 코드 부분을 **임계 구역(critical section)**으로 설정한다. 임계 구역의 중요한 특징은 다음과 같다.

- 임계 구역 내에서는 적어도 하나 이상의 다른 프로세스와 공유하는 데이터에 접근 및 갱신한다.
- **한 프로세스가 임계 구역을 수행하는 동안에는 다른 프로세스들은 그들의 임계 구역을 수행할 수 없다**. 
- 각 프로세스는 자신의 임계 구역에 진입하기 위해서 진입 허가를 요청해야 한다. 

진입 허가를 요청하는 코드 부분을 진입 구역(entry section), 임계 구역 이후 코드 부분은 퇴출 구역(exit section)이라 부른다. 이들을 모두 총칭하여 임계 구역 외의 코드 부분을 **나머지 구역(remainder section)**이라 부르기도 한다. 

이렇게 설정한 임계 구역 문제를 해결하기 위한 기법들은 항상 아래와 같은 3가지 요구 조건을 충족해야 한다. 

- Mutual Exclusion: 특정 프로세스가 자신의 임계 구역을 실행 중이라면, 다른 프로세스들은 그들 자신의 임계구역을 실행할 수 없다.
- Progress: 현재 자신의 임계 구역을 수행하고 있는 프로세스는 없고 임계 구역으로 진입하고자 하는 프로세스들만 있다면, **나머지 구역에서 실행 중이지 않은 프로세스들끼리만** 다음에 누가 임계 구역을 수행할 지 결정해야 한다. 그리고 **이 결정은 무한정 연기되서는 안된다**.
- Bounded Waiting: 특정 프로세스가 자신의 임계 구역을 수행하기 위해 진입 허가를 요청한 시점부터 그 요청이 허용될 때까지 다른 프로세스들이 그들의 임계 구역에 진입하도록 허용되는 횟수에 한계가 있어야 한다. 즉 임계 구역 진입을 위한 대기가 무한히 길어져서는 안된다. 

## Peterson Solution

Peterson Solution은 **두 개의 프로세스**가 다음과 같은 두 개의 데이터 항목을 공유하여 해결하고자 한다.

- `int turn` : 임계 구역 진입할 순번
- `boolean flag[2]` : 각 프로세스의 임계 구역 진입 준비 여부를 담은 배열 

### 프로세스 구조 

P0 프로세스의 구조를 살펴보자.

```c
flag[0] = true;
turn = 1;

while(flag[1] && turn == 1) { /* 대기 */ };
/* Critical Section */
flag[0] = false;
/* Remainder Section */
```

- 임계 구역을 진입하길 원한다면 flag 배열 값을 true로 설정한다.

- 이후 turn 값을 1로 설정해주는 데, 이렇게 함으로써 <u>다른 프로세스가 임계 구역 진입을 원할 시에 진입 가능하도록 보장</u>해줄 수 있다. 

  > 만약 두 프로세스가 동시에 진입을 원한다면 두 프로세스에 의해 turn 값은 거의 동시에 0 혹은 1로 지정이 되겠지만, turn 변수는 오직 하나의 값만 가질 수 있으므로 궁극적으로 설정된 값이 진입 순서를 결정한다. 

- 이후 `flag[1] && turn == 1` 인 동안, 즉 P1 프로세스가 진입 준비까지 마치고 자기 순번이 되어 임계 구역 수행 중인 동안, P0 프로세스는 진입 대기 중에 있게 된다. 

- P1 프로세스가 임계 구역 수행을 완료하고 나머지 영역을 진입하기 전에 자신의 flag 값을 false로 변경하게 되고, 이후 turn 값이 0이 된다면 비로소 P0 프로세스가 임계 구역에 진입하게 된다.

### 요구 조건 충족 

이러한 해결 방법은 앞서 보았던 3가지 요구 조건을 모두 충족할 수 있다.

- Mutual Exclusion: 두 프로세스가 모두 임계 구역으로 진입 하고자 flag 배열 값을 true로 설정했다 하더라도, turn 값에 의해 진입 가능한 프로세스가 결정되기 때문에 한번에 하나만 실행 가능하다.
- Progress: 각 프로세스에서 turn 값을 다른 프로세스의 순번으로 지정해줌으로써, 자기가 한번 진입 했다면 다른 프로세스도 한번은 진입할 수 있도록 보장한다.
- Bounded Waiting: 다른 프로세스가 자신의 진입을 가능하도록 설계함으로써, 프로세스들이 무한히 진입 대기하지 않을 수 있도록 한다. 

### 한계 

Peterson Solution에는은 3개 이상의 프로세스 구조에서는 적용하기 어렵다는 점에서 확장성에 한계가 있고, 이 방법이 어떠한 경우에도 올바르게 동작함을 보여야 하지만, 이러한 증명은 NP 문제로 매우 복잡하다.

사실 Peterson Solution 뿐만 아니라 <u>임계 구역 문제를 해결하기 위한 소프트웨어 기반 해결책</u>들은 사실 여러 한계점이 존재할 수 밖에 없다. 따라서 동기화 작업을 위한 하드웨어 지원이 대두되었다. 

## Hardware Instructions

현재 많은 기기들이 제공하고 있는 **특별한 하드웨어 명령어**들을 통해 우리는 임계 구역 문제들을 비교적 간단하게 해결할 수 있다. 

- **인터럽트 되지 않는** 하나의 단위
- 이들은 원자적으로(atomically) 수행된다.

2가지 명령어를 살펴보자.

### Test And Set

인자 값을 true로 바꾸고, 본래 인자 값을 반환한다. `while(TestAndSet(&lock))` 동안 대기

```c
boolean TestAndSet(boolean *target) {
	boolean rv = *target;
	*target = true;
	return rv;
}
```

### Swap

인자로 받은 두 값을 바꿔준다.  `while(waiting[i] == true) swap(&lock, &waiting[i])`

```c
void Swap(boolean *a, boolean *b) {
	boolean temp = *a;
	*a = *b;
	*b = temp;
}
```

-> Mutual Exclusion 해결. Bounded Waiting은 유저 프로그램에서 제공해야해...

## Semaphores

세마포어는 정수 변수로서, 초기화를 제외하고는 `wait()` 와 `signal()` 이라는 **원자 연산**으로만 접근 가능하다.

- `wait` : 세마포어 값을 통해 임계 구역에 진입 가능한지 확인한 후 가능하다면 통과, 가능하지 않다면 세마포어 값을 계속해서 검사하며 대기 후 최종적으로 진입 가능하게 될 때 통과시켜야 한다.
- `signal` : 세마포어 값을 조작함으로써 다른 프로세스들에게 임계 구역 진입이 가능하다는 것을 알려야 한다.

먼저 세마포어를 counting, binary 나눌 수 있음.

- Binary는 0과 1 -> 0은 진입한 프로세스 없으므로 진입 가능, 1은 진입 불가능
- Counting 세마포어는 세마포어의 값이 제한 없는 영역을 갖게 되는 방식으로, 초기값은 보통 자원의 수로 정해진다.

### Binary 세마포어 구현

- wait(P) -> `while(TestAndSet(S))` 동안 대기하다가 누군가의 signal 호출을 통해 S가 0이 되었다면 while 탈출 후 임계 구역 진입할 수 있게 된다. 물론 TestAndSet 에서 S를 1로 설정하므로 다른 프로세스들은 진입 불가능 
- signal(V) -> `S = 0`  설정하여 wait 에서 대기 중인 프로세스들에게 진입 가능을 알림

### Counting 세마포어 구현

이러한 Binary 세마포어를 가지고 Counting 세마포어를 구현해보자. 이떄 필요한 값은 다음과 같다.

- int `C`:  자원들의 접근 제어를 위한 세마포어 값. 초기값은 자원의 개수
- Binary Semaphore `S1` : Couting Semaphore 값, 즉 `C` 에 대한 접근 제어를 위한 세마포어 
- Binary Semaphore `S2` : 프로세스들의 block 및 wakeup을 제어하기 위한 세마포어

여러 프로세스들의 임계 구역 진입을 관리하는 세마포어다. 따라서 여러 프로세스에서 이 세마포어 값에 접근할 것임. 그러니 이 세마포어를 접근하는 것을 관리하는 세마포어가 필요. 

먼저 wait 연산 로직을 살펴보자.

```
P(S1); // C 값 조작을 위한 대기
C--;   // 대기 끝 -> C 값 조작

/* 나 말고 다른 프로세스가 P(S1) 내에서 대기 중인 상태라면 */
if(C < 0) { 
	V(S1);  // C값 조작 가능하다고 시그널 보내 
	P(S2);  // 그 시그널을 받을 프로세스들은 block된 상태일 것. 따라서 P(S2) 통해 wakeup에 대한 대기
}
/* 대기 중인 프로세스가 없다면 */
else {
	V(S1);  // 추후 진입 요청할 프로세스 위해 시그널은 보내야함. 근데 따로 wakeup할 프로세스 없으니 P(S2) 안해두댐
}
```

다음은 signal 연산 로직이다.

```
P(S1); // C 값 조작을 위한 대기
C++;   // 대기 끝 -> C 값 조작

/* 다른 프로세스들이 P(S1) 내에서 대기 중인 상태라면 */
if(C <= 0) {
	V(S2);  // P(S2)를 통해 block/wakeup 기다리던 프로세스가 이를 수행할 수 있도록 시그널 보내
}
V(S1);    // 이제 C값 조작 가능하다고 시그널 보내 
```

### Wait and signal 구현 

이제 세마포어를 다루는 함수 구현 방법들에 대해 살펴보자.

- **Busy Waiting**

  `wait` 에서 임계 구역 진입이 가능할 때까지 **loop**을 돌며 대기하는 방식이다. 세마포어는 정수 값으로 설정하면 되고, ~

  이는 CPU 사이클을 낭비하는 방식일 뿐더러, 대기 중인 프로세스 중에 누가 다음으로 임계 영역에 진입하게 될 지 예측하기 어렵다는 단점이 있다.

- **Sleep Queue**

  이번엔 진입 대기 동안 loop을 도는게 아니라 특정 큐에 추가하여 이들을 관리한다. 큐에 들어간 프로세스들은 일시 중지 되었다가 이후 큐에서 꺼내지면서 실행이 재게된다. 이제 세마포어는 정수 값 뿐만 아니라 sleep queue를 관리해야하므로, 이를 담는 자료구조로 설정되어야 한다.

  ```
  typedef struct {
  	int value;   
  	struct process *list;
  } semaphore;
  ```

### 세마포어의 단점 

- deadlock 가능성 
- 만약 P와 V 연산을 잘못 사용한다면? 이에 대한 대책 없음;

이로 인해 high-level 언어에서도 동기화를 추가로 처리해줘야 한다는..

## Monitor

- 한번에 하나의 프로세스만 모니터에서 활동하도록 보장
- 자바의 스레드에서 동기화를 위한 방법으로 사용된다
- 애플리케이션은 P,V 연산에 대한 고려 없이 함수 호출 가능
- ex. 트랜잭션 