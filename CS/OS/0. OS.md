# Operation System
운영체제은 무엇인지, 핵심 역할과 발전 과정에 대해 정리한다.

## OS (Operation System)

먼저 우리는 소프트웨어를 크게 Application Software와 System Software로 구분할 수 있다.

- Application Software는 Chrome, Game, Notion 등 특정 용도로 사용되는 소프트웨어로, 수많은 응용 프로그램이 존재한다.
- System Software는 Compiler, Assember, OS 등 컴퓨터 시스템을 구동시키는 소프트웨어로, 프로그램들이 동작하기 위해서 반드시 필요한 소프트웨어이다. 

운영체제는 컴퓨터가 켜지면 가장 먼저 실행되고 항상 동작하는 프로그램으로, 핵심 기능은 **자원에 대한 관리 및 감시 활동과 하드웨어 제어 기능**이다.

동시에 실행되고 있는 많은 프로세스들을 감시하며 어떤 프로세스에게 어떤 자원을 할당해줄지 관리한다. 이러한 운영체제의 통제 기능을 통해 각 프로그램들은 자원을 사용하고자 할 때 직접적으로 하드웨어에 접근할 필요가 없으며, 또 부적절한 접근으로부터 자원을 보호할 수도 있다. 또 Device Driver 등 소프트웨어를 통해 그래픽 카드, 네트워크 카드, 마우스 등 컴퓨터 외부 하드웨어 장치와 운영 체제 간 통신을 관리한다. 

> - 운영 체제가 실행되는 모드 = 하드웨어 접근 권한이 있는 모드 =  Supervisor Mode = Kernel Mode = Privileged Mode
> - 일반 프로그램이 실행되는 모드 = 하드웨어 접근 권한이 없는 모드 = User Mode = UnPriviledged Mode



## OS 구성 요소

- Kernel : 앞서 말한 자원 할당, 하드웨어 관리, 보안 등 운영체제의 핵심 기능을 담당하는 부분이다. 메모리에 항상 상주해있다. (= 항상 동작)
- GUI, CUI 등 사용자 인터페이스 
- libc, win32.dll 같은 자주 사용되는 함수들의 집합인 Library

> OS = Kernel vs OS = Kernel + GUI + Library



## OS 핵심 역할

### 하드웨어 사용을 위한 Abstraction

우리가 사용하는 모든 응용 프로그램들은 하드웨어에 직접적으로 다루는 코드를 작성하지 않아도 컴퓨터의 메모리, 디스크 등 장치들을 사용하며 동작한다. 또한 프로그램끼리 네트워크 통신을 할 때 상대 프로그램이 위치 혹은 사용하는 장치가 물리적으로 어디에 있는지 몰라도 통신이 가능하다. 이는 운영체제의 **Abstraction Layer**에서 이들을 모두 관리해주는 덕분이다. 

- **Process** : 일반적으로 Program은 순차적으로 실행될 명령어들을 담은 기계어 모음으로, 운영체제의 도움 없이는 실행될 수 없다. 이는 디스크에 정적인 파일(`.out` or `.exe`)로 저장되어 있다가, 운영체제가 이를 메모리에 가져와 **Process** 형태로 배치하여 CPU에서 실행시킨다. 각 프로세스는 고유한 메모리 공간 등을 가지고 독립적으로 실행되고, 운영체제는 이러한 프로세스들을 병행하여 실행시킴으로서 사용자가 여러 프로그램을 동시에 사용할 수 있도록 제공한다. 
- **Address Space**: 여러 프로세스들이 동시에 공유하고 있는 물리적 메모리 공간은 안정적인 시스템과 보안을 위한 철저한 관리가 필요하다. 이를 위해 **Virtual Memory** 라는 개념을 통해 각 프로세스가 고유한 메모리 영역을 가지도록 하고 각자의 메모리 영역을 침범하지 않도록 한다. 마우스, 키보드, 네트워크 카드 등 I/O Device 들을 사용하기 위한 메모리 영역(Memory Mapped)도 구분하여 관리한다. 
- **File**: 물리적 저장 장치를 관리하기 위한 개념으로, 프로세스는 특정 데이터의 실제 물리적인 위치를 알지 않아도 읽고 쓸 수 있다. 
- **Port** : 컴퓨터 시스템이 통신할 때 사용되는 Communication Endpoint이다. 각 프로세스들은 서로의 실제 위치를 몰라도 Port를 통해 네트워크 통신을 할 수 있다. 

### 자원 공유 및 분배를 위한 Policy 

컴퓨터의 한정된 자원을 여러개의 프로그램들에게 어떻게 분배하고 관리할지에 대한 **Policy**를 결정한다. 

운영체제는 PC, 스마트폰, 서버, 데이터 센터, 자동차, IoT 시스템 등 다양한 기기에 탑재되어 있고, 각각의 기기들은 뚜렷한 목적을 가지고 구동된다. 이때 자원 관리에 대한 Policy는 **이러한 기기들의 특징과 목적에 맞게 적절하게 튜닝**되어야한다. 

예를 들어보자. PC나 스마트폰은 사용자에게 빠른 응답시간과 높은 성능을 제공하는 것이 중요하다. 따라서 사용자가 게임과 뮤직 플레이어를 동시에 사용하고자 할 때, 게임은 빠른 데이터 로딩과 응답 속도를 필요로 하므로 SSD에 두고 상대적으로 로딩 속도가 덜 중요한 뮤직 플레이어(음악 재생 후 대략 3분간은 데이터 응답 필요 없음)은 HDD에 두어 성능을 높인다. 또한 배터리 지속 시간이 비교적 중요한 스마트폰은 일정 시간 사용하지 않는 프로그램이나 하드웨어 자원을 종료시키는 Policy를 둠으로서 에너지를 아낄 수 있다. 반면 자동차에 탑재된 운영체제는 무엇보다 사용자의 안전에 포커스되어야하므로 주행과 정차를 담당하는 프로세스를 항상 우선순위에 두는 Policy를 둘 것이다.



## OS 발전 과정

### 1. Batch System (일괄 처리)
- 일정량 혹은 일정 기간 데이터를 모아서 한번에 처리하는 방식
- 실행할 데이터(프로그램)을 **Punch Card** 등을 통해 컴퓨터에 입력하면 컴퓨터는 이를 메모리에 적재한 후 실행한다. 한번 시작한 Job이 끝나야 반드시 다음 Job이 시작될 수 있고, 그렇기에 실행 기간 동안에는 User Interaction이 불가능하다.
- 사람이 프로그램의 실행 순서대로 컴퓨터에 프로그램을 입력 및 실행시키는 방식이므로, 사람이 Job Scheduling을 하는 방식이다.

**Issue**

- 사람이 Scheduling을 하므로, 프로그램 실행 간 <쉬는 시간? 간격?>이 존재할 수 밖에 없다.
- I/O 장치보다 CPU 속도가 훨씬 빨랐기 때문에, CPU가 빈번히 Idle 상태(아무 작업도 하지 않는 상태)로 전환되는 한계가 존재한다.
### 2. Automatic Job Scheduling
- 여러 개의 프로그램들을 순차적으로 실행해주는 방식 
- 사람이 아닌 **스케줄링을 담당하는 소프트웨어**가 프로그램을 자동으로 실행시켜주므로 성능이 좀 더 향상되었다. 

**Issue**

- 여전히 I/O 장치와 CPU의 속도 차에 의해 CPU가 Idle 상태로 전환되는 문제는 해결하지 못했다.
- 특정 프로그램의 실행이 오래 걸릴수록, 이후에 실행될 프로그램들의 대기 시간이 길어진다. 

>  Storage 접근 속도 : register > cache > main memory > solid-state disk > magnetic disk

### 3. Spooling (Simultaneous Peripheral Operation On-Line)
- 속도가 빠른 **디스크를 버퍼처럼 사용**해서 I/O 장치에서 미리 읽는 방식
- 프린트 작업을 예로 들어보면, 인쇄할 문서들을 디스크나 메모리의 버퍼에 로드해놓으면 프린터는 버퍼에서 데이터를 가져와 자신의 처리 속도로 프린트 작업을 수행한다. 그동안 컴퓨터는 다른 작업을 수행할 수 있다. 
- 프린터 장치의 프린트 작업과 CPU의 연산 작업을 동시에 실행할 수 있으므로 성능이 향상된다.

>  I/O 장치와 CPU 속도 차를 완화하기 위한 방식 중 Buffering도 있다. Buffering은 I/O 장치 실행 시간동안 버퍼에 다음으로 처리할 작업들을 미리 읽어 저장하는 방식이다. 

### 4. Multi-programming (다중 프로그래밍)
- 여러 개의 프로그램을 **메모리에 동시에 올려놓고** 순차적으로 실행하는 방식
- 실행 중이던 프로그램이 I/O처리 등으로 CPU를 사용하지 않게 된다면 바로 다른 프로그램에 CPU를 할당시키는 방식으로, CPU의 Idle Time을 현저히 줄이고 CPU의 활용도를 극대화할 수 있다. -> CPU가 여러 프로그램을 동시에 실행하는 것처럼 처리 가능

**Issue**

- 여전히 모든 작업들이 끝나기 전까지 **User Interaction**이 불가능하므로, 사용자는 실행 중인 작업에 대해 관여할 수가 없다. 
	<img src="https://i.imgur.com/tLDQU8a.png" style="zoom:40%;" />
- 특정 프로그램이 의도적으로 I/O를 하지 않는다면 다른 프로그램들이 수행되지 못한다는 문제점들이 발생했다. -> 공평성 유지 문제
- 초반에는 프로그램 간 스케줄링을 FCFS 방식으로 수행했지만, **특정 작업들에 우선순위를 부여할 필요**도 생기게 되었다. 즉 더 복잡하고 효율적인 스케줄링 기법이 요구되었다.
- 여러 개의 프로그램이 동시에 메모리에 상주하므로 **메모리 관리 및 보호 시스템**이 요구되었다.

### 5. Time Sharing (시분할 시스템)
- CPU의 실행 시간을 나눈 후, **모든 프로그램이 동일한 시간(Time Slice)동안 CPU를 점유**할 수 있도록 스케줄링하는 방식
- 각 프로그램들은 주어진 Time Slice 동안 CPU를 점유하고 그 시간이 끝나면 무조건 다른 프로그램에게 양보해야한다. 
- 작업 간 전환이 **Context Switching**을 통해 이루어지고, 그동안 User Interaction이 가능해졌다. 즉, 컴퓨터 응답 속도가 빨라지고 사용자가 실행 중인 프로그램에 관여가 가능해졌다. 
### 6. Multi-tasking (멀티 태스킹)
- 하나의 프로그램을 여러개의 Task로 나누고, CPU가 이 Task들을 돌아가면서 수행하는 방식 -> 여러 프로그램들이 동시에 실행된다. 
- 프로그램을 하나로 관리하는 것보다 동시에 실행해도 되는 Task들 (ex. UI 처리, 입출력 처리 등) 으로 나눠서 관리하는 것이 더 효율적이다.

**Issue**

- 메모리가 초과되어 공간을 확보해야할 때, 몇개의 프로세스들은 (실행 상태를 저장 후) 디스크에 옮겨놓는 방식을 사용하기도 한다. 이때 응답 시간을 위해서 메모리와 디스크 간의 Swap in/out 시간이 너무 길어지지 않도록 한다. 
- Task 간의 Orderly Execution이 필요할 수도 있다. (ex. T2는 반드시 T1 종료 이후에 실행되어야함) -> 동기화, Deadlock 등 고려해야한다.

### 7. Mutli-processor (멀티 프로세싱)

- CPU 여러개!

> **멀티 프로그래밍 vs 멀티 태스킹 vs 멀티 프로세싱** 
>
> - 멀티 프로그래밍 : 여러 프로그램을 메모리에 동시에 올려놓고 순차적으로 수행하는 방식 
> - 멀티 태스킹 : CPU가 여러 프로그램들을 동시에 수행할 수 있는 방식
> - 멀티 프로세싱 : 여러개의 CPU 사용 

> **시분할 시스템 vs 멀티 태스킹** 
>
> - 프로그램을 **여러개의 작업들로 쪼개고** 이 작업들을 번갈아가며 실행하며, CPU가 여러 프로그램들을 동시에 실행할 수 있도록 하는 방식
> - 시분할 시스템은 (User Interaction에 대한) 응답 시간을 최소화하는 데 목적을 두고, 멀티 태스킹은 CPU의 Idle 전환 시간을 줄여 효율성을 극대화하는 데 목적을 둔다.

### 기타 시스템 

- 분산 시스템
- Clustered System
- Embedded System
- Real-Time System : 프로그램의 완료 시간이 정해져 있으며, 반드시 이 시간에 프로그램 실행이 종료되어야한다. (ex. 실시간 주행 시스템)

