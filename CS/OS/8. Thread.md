# Thread

## Thread 

- CPU 이용의 기본 단위(Execution Unit)
- Process 내 실행 흐름
- 스레드 ID, **프로그렘 카운터(PC), 레지스터 집합, 스택**으로 구성
  - PC: 현재 실행 중인 instruction 주소를 가리키는 카운터 -> interrupt 후 다시 스레드 실행 재개 시 필요
  - Register Set: CPU의 레지스터 값들 
  - Stack: 함수 실행을 위한 임시 데이터 저장 장소(매개변수 등) -> 각 스레드들의 고유 정보 
- 같은 프로세스에 속한 스레드들은 **코드, 데이터 섹션**, 열린 파일이나 신호와 같은 운영체제 자원들을 공유 

### 스레드 프로그래밍 이점

<u>응답성, 자원 공유, 경제성, 규모 적응성</u>

- Responsiveness: 특정 응용 프로그램이 긴 작업을 수행하더라도 프로그램의 수행이 계속되는 것을 허용함으로써, 사용자에 대한 응답성 증가
- Resource Sharing: 프로세스는 공유 메모리나 메세지 전달 기법 등 IPC를 통해 자원 공유를 할 수 있으므로 프로그래머가 이를 명시적으로 처리해야 했지만, 스레드는 자동으로 프로세스 자원과 메모리를 공유한다. 
- Economy: 스레드를 생성하고 문맥 교환하는 것이 프로세스와 비교했을 때 더 빠르고 메모리를 덜 소비한다.
- Scalability: 멀티 프로세서(다중 처리기) 구조에서 다중 스레드의 이점은 더욱 증가한다. 단일 스레드 프로세스는 프로세서가 아무리 많아도 오직 한 처리기에서만 실행될 수 있지만, 다중 스레드 프로세스는 각각의 스레드가 다른 처리기에서 병렬로 수행될 수 있다. 

## Multi-core Programming

멀티 코어 시스템은 하나의 칩에 여러 개의 Computing Core를 탑재하는 시스템을 말한다.

> 병행성과 병렬성 
>
> - CPU 스케줄러가 스레드 간에 빠르게 전환하며 둘 이상의 작업이 진행될 수 있도록 하는 것을 병행성 이라고 한다.
> - 여러 개의 CPU가 동작하면서 여러 작업을 동시에 실행될 수 있도록 하는 것을 병렬성 이라고 한다. 

멀티 스레딩은 멀티 코어 시스템에서 굉장히 효율적임

1. 여러개의 코어가 여러개의 스레드를 병렬적으로 (동시에) 실행 가능
2. 코어들은 캐시를 공유하기 때문에, 프로세스 자원을 공유하는 멀티 스레딩 프로그래밍에 보다 효율적임

> multi-core vs multi-processor
>
> - 멀티 코어 -> CPU 내에 여러 개 코어 배치
> - 멀티 프로세서 -> 여러개의 CPU를 배치 

## Multi-threading Models

### User Thread and Kernel Thread

- User Thread

  - 커널 영역 위에서 지원되며 커널의 지원 없이 관리된다. -> User Level의 라이브러리가 스레드 생성 및 스케줄링 관리

  - 동일한 메모리 영역에서 스레드 생성 및 관리되므로 속도가 비교적 빠르다. 

  - 하지만 한 번에 하나의 스레드만이 커널에 접근할 수 있기 때문에, 하나의 스레드가 시스템 콜을 요청한다면 해당 프로세스의 다른 스레드들은 모두 block 상태에 놓이게 된다.  

    >  커널의 입장에서는 프로세스 내 여러 스레드들이 있어도 결국 이를 하나의 프로세스로만 간주하기 때문 

- Kernel Thread

  - 운영체제에 의해 직접 지원되고 관리된다.
  - 커널이 직접 스레드 스케줄링을 관리하므로, 하나의 스레드가 시스템 콜을 호출하여 block 되면 다른 스레드를 실행하여 전체적인 thread blocking을 막는다. 
  - 또 멀티 프로세서 시스템에서는 여러개의 프로세서가 여러개의 스레드들을 병렬적으로 수행할 수 있다.
  - <u>유저 스레드보다 생성 및 관리가 느림 -> 왜</u> ?

### Thread Mapping Model

- N:1
  - 여러개의 유저 스레드가 1개의 커널 스레드로 매핑 
  - 한번에 하나의 유저 스레드만 커널에 접근 가능하므로 -> 진정한 동시성 지원할 수 없고, 멀티 프로세서 시스템에서도 하나의 프로세서만 수행 
- 1:1
  - 각 유저 스레드를 각각 하나의 커널 스레드로 매핑 
  - 여러 스레드들이 동시에 시스템 콜을 호출할 수 있고, 여러 스레드를 멀티 프로세스에서 병렬로 수행할 수 있게 되었음
  - 유저 스레드 개수만큼 커널 스레드를 만들어야하므로, <u>커널 스레드가 많아질수록 시스템 성능에 부담</u>
  - 리눅스와 윈도우 운영체제가 이 모델을 구현 

- N:N
  - 여러 개의 유저 스레드를 그보다 작은 수, 혹은 같은 수의 커널 스레드로 매핑(멀티 플렉스)
  - 여러 스레드들을 병렬적으로 수행할 수 없는 N:1 모델과 커널 스레드의 개수가 너무 많아지면 안되는 1:1 모델의 단점을 보완
  - 구현하기 어렵고, 시스템 코어 수가 증가함에 따라 커널 스레드 수를 제한하는 것의 중요성이 줄었음

## Threads Library

- C Pthreads 
- Windows Threads
- Java Thread API

## Implicit Threading(암묵적 스레딩)

암묵적 스레딩이란, 스레드의 생성과 관리 책임을 프로그래머로부터 **컴파일러와 실행시간 라이브러리에게 넘겨주는 전략**을 의미한다. 다중 코어 및 프로세서 시스템이 등장하면서 점차 다중 스레딩을 설계해지는 것이 매우 복잡해지면서 사용하게 된 전략이다. 

### Thread Pools

프로세스를 시작할 때 아예 일정한 수의 스레드들을 미리 풀로 만들어두는 기법이다. 

웹 브라우저 같은 경우 서버가 요청을 받을 때마다 새로운 스레드를 생성하게 되면 스레드의 생성 및 제거가 너무 자주 수행이 되어야 하고, 실제로 서비스가 수행되는 시간보다 스레드가 생성되는 시간이 길어질 수도 있다. 따라서 미리 제한된 수의 스레드들을 생성하여 풀에 할당해두고, 새로운 스레드가 필요할 때마다 풀에서 가져오고 작업이 완료되면 다시 풀에 넣어두는 방식으로 동작한다면, **잦은 스레드 생성에 따른 시스템 부하**를 줄일 수 있다. 

이러한 풀에서 관리할 스레드 개수는 CPU 개수, 물리 메모리 용량, 동시 요청 클라이언트 최대 개수 등을 고려하여 정해질 수 있고, 풀의 활용도를 관찰하여 동적으로 풀의 크기를 바꾸어줄 수도 있다. 

### fork-join 

...

## Threading Issues

멀티 스레딩 프로그램을 설계할 때 고려해야 할 몇 가지 문제들을 살펴보자.

### Fork and exec

- 여러 스레드를 가지고 있는 프로세스가 fork를 호출한다면, 새로운 프로세스는 모든 스레드를 다 복제해야하는가? 아님 하나의 스레드만 가지는 프로세스어야하는가?
  - linux 계열 운영체제에서는 2가지 버전의 fork를 모두 제공하는 것으로 해결한다. 부모 프로세스의 모든 스레드를 복사할 수 있고, fork를 호출한 스레드만 복제할 수도 있는 것이다. 
- 그렇다면 2가지 버전의 fork 중 어떤 걸 쓰는게 좋은가?
  - 만약 fork 호출 후 바로 exec를 호출한다면 어짜피 새로운 프로그램이 곧 모든 것을 대체할 것이기 때문에, fork에서 모든 스레드를 복사하는 것이 불필요하다. 따라서 이러한 경우에는 fork를 호출한 스레드만 복사하는 것이 적절하다.
  - 반면 fork 호출 이후 exec를 호출하지 않는다면 새 프로세스는 모든 스레드를 복사하는 것이 필요할 수도 있다.

### Signal handling

운영체제에서는 **특정 이벤트가 발생**하면 이와 관련된 **신호를 프로세스에 전달**하여 해당 **신호에 대한 처리가 반드시 수행**되도록 한다. 이러한 신호는 동기적 신호와 비동기적 신호로 구분할 수 있다.

- 동기적 신호: 불법적인 메모리 접근, 0으로 나누기 등에 의한 신호이다. 이러한 신호를 발생시킨 연산을 수행한 프로세스에 반드시 전달해야 한다.
- 비동기적 신호: 사용자가 ctrl+c를 눌러 프로세스를 강제 종료시키거나 타이머가 만료되는 등 프로세스 외부로부터 전달받는 신호이다.

단일 스레드 프로그램에서는 신호를 프로세스에 정확히 전달 및 처리해주기만 하면 되지만, 멀티 스레드 프로그램에서는 신호 처리가 간단하지 않다.

- 동기적 신호는 **그 신호를 야기한 스레드에 전달**되어야 하고, 다른 스레드에는 전달되면 안된다.
- 반면 비동기적 신호는 해당 스레드에만 전달되어야 할 지, 프로세스 내 모든 스레드에 전달되어야 할 지 모호하다. 이 역시 특정 운영체제에서는  `pthread_kill`, `kill` 함수 등을 통해 두 경우 모두 처리할 수 있도록 지원하고 있다. 

### Thread cancellation

스레드가 끝나기 전에 그것을 강제 종료시킬 수 있다. 여러 스레드가 데이터베이스를 병렬로 검색하다가 그 중 한 스레드가 결과를 찾아서 나머지 스레드를 취소해도 되는 경우나, 사용자가 웹 브라우저에서 이미지를 읽어 오는 과정에서 중단 버튼을 눌러 이 작업을 처리하던 스레드가 중지되어야 하는 경우 등이 그 예시이다. 

이렇게 취소 되어야 할 스레드를 목적 스레드라고 부른다. 그리고 목적 스레드의 취소는 2가지의 방식으로 발생할 수 있다.

- 비동기적 취소: 한 스레드가 즉시 목적 스레드를 강제 종료
- 지연 취소: 목적 스레드가 주기적으로 자신이 강제 종료 되어야 할 지 점검

이러한 스레드 취소 과정에서 문제가 되는 부분은 **취소 스레드에 할당된 자원**이다. 해당 스레드에 할당된 자원을 다른 스레드가 사용하고 있을 수도 있고, 혹은 해당 스레드가 공유 자원을 수정하고 있는 상황에서 취소 요청이 왔을 수도 있다. 

### Thread Local Storage

상황에 따라 각 스레드가 자신만 액세스할 수 있는 데이터를 가져야 할 필요가 있다. 이러한 스레드 고유 데이터를 **TLS**(Thread-local storage)라고 부른다. 대부분의 스레드 라이브러리 및 컴파일러는 TLS를 지원하고 있다. (ex. java의 `ThreadLocal<T>`)

각 스레드들이 가지게 되는 **독립적이고 고유한 공간**이라는 점에서 Stack 영역과 TLS를 혼동할 수 있으나 이는 다른 목적을 가지고 있다.

- Stack 영역은 스레드 내부에서 함수 호출 시 지역 변수와 매개 변수 등을 저장하기 위한 공간이다. 각 스레드에서 호출되는 함수들이 독립적으로 수행되도록 하고, 각 스레드의 작업들이 서로 방해 받지 않도록 **안전한 동시성을 제공**할 수 있다.  
- 반면 TLS는 스레드에 부여되는 식별자 등 스레드 별로 독립적으로 유지되어야 하는 데이터를 저장하기 위한 영역이다. 

