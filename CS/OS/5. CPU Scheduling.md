# CPU Scheduling

> 책은 chapter 5

CPU 이용률을 최대화하고 더 생산적인 시스템을 만들기 위한 CPU 스케줄링에 대해 정리한다.

## CPU-I/O Burst Cycle

프로세스의 실행은 CPU를 실행하는 **CPU Burst** 와 I/O 대기하는 **I/O Burst** 로 사이클이 구성된다. 프로세스는 이 두 상태를 교대로 왔다 갔다 하다가 실행을 종료하게 되는 것이다. 

또 프로그램들을 분석해보면 긴 CPU Burst 지속 시간을 갖는 CPU 지향 프로그램이 있고 짧은 CPU Burst 시간과 긴 I/O Burst 시간을 갖는 I/O 중심의 프로그램이 있다. 이러한 프로그램의 특징에 따라 적절한 CPU 스케줄링이 필요하다.

> 분석 결과 일반적으로 프로세스들의 CPU Burst 시간은 3-5ms 라는 짧은 시간에 불과했다. 

## CPU Scheduling

CPU가 idle 상태로 전환되면 운영체제(CPU 스케줄러)는 Ready Queue에 있는 프로세스 중 하나를 선택해서 실행해야한다.  이때 준비 큐가 반드시 FIFO 방식의 큐가 아니어도 됨을 주의하자. 준비 큐는 FIFO 큐, 우선순위 큐, 트리 혹은 순서가 없는 연결 리스트로도 구현이 될 수 있다. 어쨌든 준비 큐에 있는 모든 프로세스들은 CPU에 실행될 기회를 기다리며 대기하는 상태고, 이때 큐에 들어가는 레코드들은 프로세스의 PCB(프로세스 제어 블록)들이다.

### 언제 스케줄링이 발생하나?

스케줄링의 결정은 4가지 상황에서 발생할 수 있다.

1. 프로세스의 상태가 Running -> Waiting 로 전환 (I/O 요청을 대기하거나 wait()을 호출하여 자식 프로세스 종료를 기다리는 경우)
2. 프로세스의 상태가 Running -> Ready 로 전환 (인터럽트가 발생한 경우)
3. 프로세스의 상태가  Waiting -> Ready 로 전환 (I/O 종료된 경우)
4. 프로세스의 상태가  Running -> Terminated 로 전환 (프로세스 실행이 종료된 경우)

### 비선점과 선점 스케줄링 

- **비선점 스케줄링**: CPU에 한 프로세스가 할당되면 해당 프로세스는 실행이 종료되거나(1) 혹은 대기 상태로 전환하여(4) 스스로 CPU를 방출할 때까지 점유할 수 있다. 
- **선점 스케줄링**: 하지만 위 2,3번의 경우를 생각해보자. 예를 들어 인터럽트 같은 경우, 반드시 커널이 인터럽트 발생 동시에 처리를 해야할 필요가 있는데 이때 기존 CPU에서 실행되던 프로세스는 실행을 멈추고 Waiting 큐로 들어가야한다. 즉 CPU 스케줄러가 정해진 기준에 의해 선점될 프로세스를 선택할 수 있는 것이다. 

### Dispatcher 

디스패처는 CPU 코어의 제어를 CPU 스케줄러가 선택한 프로세스에 주는 모듈이고, 다음과 같은 작업을 담당한다. 

- 프로세스 간 Context Switching
- User Mode로 전환
- 프로그램을 다시 시작하기 위해 사용자 프로그램의 적절한 위치로 jump 

이때 소요되는 시간으로 dispatch letency(디스패치 지연)이라고 한다. 

> 추후 추가 (p.223)

## Scheduling 의 기준
- CPU 이용률(utilization): 우리는 CPU를 이용하는 시간을 극대화하는 것을 추구한다.

- 처리량(throughput): 처리량은 **단위 시간당 완료된 프로세스의 개수**로, 긴 프로세스인 경우 이 비율은 몇 초 동안 한 프로세스가 될 수 있고, 짧은 트렌직션인 경우 처리량은 초당 수십개의 프로세스가 될 수 있다.

- 총 처리시간(turnaround time): 프로세스의 입장에서는 해당 **프로세스가 실행되는 데 소요된 시간**이 중요하다. 즉 총 처리시간은 프로세스가 시작되고 종료될 때까지의 간격이다. 

  > 총 처리시간 = 프로세스가 준비 큐에서 대기한 시간 + CPU에서 실행된 시간 + I/O 시간 

- 대기 시간(waiting time): 대기 시간은 프로세스가 **준비 큐에서 대기하면서 보낸 시간의 합**이다. 스케줄링은 프로세스의 실행 시간이나 I/O 시간에 영향을 주는게 아니라 이 대기 시간의 양에 영향을 준다는 것을 유의하자.
- 응답 시간(response time): shell 같은 대화식 프로그램을 생각해보면 해당 프로그램의 총 처리시간보다는 **사용자의 요구에 얼마나 더 빨리 응답하는지**가 더 중요할 것이다. 이러한 응답 시간은 하나의 요구를 제출한 후 첫번째 응답이 시작될 때(응답 종료가 아님)까지의 시간이다. 

CPU 이용률과 처리량을 최대화하고, 총 처리시간, 대기시간, 응답 시간을 최소화하는 것이 이상적이다. 모든 운영체제는 이러한 값들을 최적화하려고 노력하지만 모든 기준을 만족하는 이상적인 스케줄은 존재할 수 없다. 따라서 시스템의 용도에 맞는 스케줄링 기법을 사용해야한다. 

## Scheduling Algorithms
> 추후 내용 보완 (p.227)

### FCFS (First Come First Served) 

CPU를 먼저 요청하는 프로세스가 CPU를 먼저 할당받는 **비선점형 스케줄링**이다. 

- 이 스케줄링은 FIFO 큐로 쉽게 관리할 수 있다. 프로세스가 준비 큐에 진입하면 해당 프로세스의 PCB를 큐에 끝에 연결하고, CPU가 가용 상태가 되면 준비 큐의 가장 앞에 있는 프로세스를 큐에서 제거 후 CPU에 할당하면 된다. 
- CPU 사용 시간이 긴 프로세스를 먼저 시작하게 되면 다른 프로세스들이 CPU를 양도받도록 기다려야하는 convoy effect가 발생한다. 반면 짧은 프로세스들이 먼저 처리가 되면 평균 대기 시간은 크게 줄어들 수 있다. 즉 FCFS 스케줄링은 프로세스들의 실행 시간에 따라 평균 대기 시간의 편차가 큰 기법이다. 

### SJF (Shortest Job First) 

CPU Burst 시간이 짧은 프로세스 순서대로 CPU에 할당되는 **비선점형/선점형 스케줄링**이다. 앞서 FCFS 스케줄링 기법에서 실행 시간이 짧은 프로세스들이 먼저 실행되면 평균 대기 시간을 최소화할 수 있다는 점을 이용해 만들어진 기법이다. 

SJF 알고리즘이 **비선점형으로** 동작한다면, CPU가 가용 상태가 될 때마다 준비 큐에 있는 프로세스 중 CPU Burst 시간이 가장 짧은 프로세스를 선택해 실행시킬 것이다. 반면 SJF 알고리즘이 **선점형으로** 동작한다면, 준비 큐에 도착한 새로운 프로세스가 현재 CPU에서 실행 중인 프로세스보다 짧은 CPU Burst 시간을 가지고 있다면 프로세스의 실행을 멈추고 새로운 프로세스로 교체한다. 이러한 선점형 SJF 기법을 **SRTF(Shortest Remaining Time First)** 라고 부른다. 

평균적으로 SRTF가 SJF 보다 더 나은 성능을 갖는다. 

### Round Robin 

CPU 스케줄러가 time quantum 혹은 time slice라는 작은 단위의 시간을 정의 후, 준비 큐를 돌면서 **한번에 한 프로세스에 한 번의 시간 할당량** 동안 CPU를 할당하는 방식이다. Round Robin은 선점형 스케줄링 방식이며, 준비 큐는 원형 큐로 동작한다. 

RR 알고리즘의 성능은 시간 할당량의 크기에 큰 영향을 받는다. 시간 할당량을 매우 크게 설정하면 결국 FCFS 기법과 유사해져 FCFS의 성능과 유사해진다, 반면 시간 할당량을 매우 작게 설정하면 매우 잦은 context switching이 발생하게 된다. 따라서 시간 할당량이 context switching에 걸리는 시간보다 더 커야 한다. 총 처리시간 역시 시간 할당량의 크기에 좌우된다. 

### Priority 

각 프로세스는 우선 순위를 가지고 있고, CPU는 높은 우선 순위를 가진 순서대로 프로세스에 할당되는 비선점형 스케줄링이다. 앞서 말했던 SJF 역시 CPU Burst를 기준으로 하는 우선순위 스케줄링 중 하나이고, 만약 우선 순위가 같은 프로세스가 있다면 FCFS 순서로 스케줄링한다. 

### starvation and aging 

우선 순위 스케줄링에서 가장 중요한 문제는 **starvation(기아 상태)** or indefinite blocking(무한 봉쇄)이다. 낮은 우선순위 프로세들이 높은 우선순위 프로세스들이 꾸준히 실행됨에 따라 순서에 밀려 CPU를 무한히 대기하는 현상을 말한다. 

이러한 문제의 해결 방안 중 하나는 **aging(노화)** 이다. aging은 오랫동안 시스템에서 대기하는 프로세스들의 우선순위를 점진적으로 증가시킨다.

### Multilevel Queue Scheduling

여러 스케줄링 기법을 조합해서 동시에 사용하는 방식이다. 

예를 들어 우선순위 스케줄링과 RR 스케줄링을 결합하는 방식을 생각해보자. 우선 순위마다 별도의 Ready Queue를 둔 후 각 큐에서는 라운드 로빈 순서로 실행을 한다. 우선순위가 아니라 프로세스의 유형 별로 Queue를 분리할 수도 있다. 포그라운드 프로세스와 백그라운드 프로세스를 구분하고, 포그라운드 큐에서는 RR 스케줄링을, 백그라운드 큐에서는 FCFS 스케줄링을 사용할 수 있다. 

### Multilevel Feedback Queue Scheduling

다단계 큐 스케줄링 기법에서는 일반적으로 프로세스들이 영구적으로 하나의 큐에만 할당된다. 이러한 방식은 오버헤드 측면에서 장점이 있으나 융통성이 작다. 반면 다단계 피드백 큐 스케줄링 알고리즘은 프로세스가 큐들 사이를 이동하는 것을 허용한다. 예를 들어 어떤 프로세스가 CPU 시간을 너무 많이 사용하면 낮은 우선순위 큐로 이동되는 방식이다 



## Multiprocessor Scheduling

멀티 프로세싱 사용된다면, 즉 여러개의 CPU를 사용한다면 더더욱 복잡해진다.

- Asymmetric Multiprocessing : 하나의 프로세스(마스터 서버)가 시스템 자료구조에 접근하여 스케줄링을 결정한다. 

- Symmetric Multiprocessing : 각각의 프로세스가 스스로 스케줄링 

  

- Processor Affinity : 특정 프로세서가 특정 CPU에서만 실행되도록 하기 -> 좀 더 효율적으로
- Load Balancing : CPU마다 Ready Queue를 둔다면? CPU가 하나의 Ready Queue를 공유한다면?

