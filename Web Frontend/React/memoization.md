# 메모이제이션

렌더링을 최소한으로 줄이기 위해 사용되는 '메모이제이션 기법'들에 대해 알아보자.

## 메모이제이션에도 비용이 든다.

일단, 메모이제이션 기법들에 알아보기에 앞서 명심해야 할 것은 메모이제이션에도 '비용'이 발생한다는 것이다.

메모이제이션 작업을 크게 2가지로 나누면 다음과 같다.

1. 값을 비교하고 렌더링 혹은 재계산이 필요한지 확인하는 작업
2. 결과물을 저장해 두었다가 이것을 다시 꺼내오는 작업

이렇게 메모이제이션 작업에도 비용이 발생하고, 이 비용이 렌더링 비용보다 저렴하다고 절대 확실할 수 없다. 이러한 비용적 고민을 하지 않고 무턱 대고 메모이제이션을 수행하는 걸 '섣부른 최적화(premature optimization)'라 하고, 더 나은 앱 성능을 위해서는 이러한 '섣부른 최적화'를 지양하고 최적화 작업에 신중하게 접근해야 한다.

> 사실 CPU와 메모리를 사용해 이전 결과물과 비교하고 저장하는 작업은 메모이제이션이나 렌더링이나 둘 다 수행하는 작업이다. 그래서 애매하다면 일단 메모이제이션을 하고 보는게 비용적으로 낫다는 의견도 있지만, 어찌되었든 메모이제이션을 할 때 성능상 이점이 있을지, 어떠한 영향을 미치게 될 지 무의식적으로 고민하는 자세가 가장 중요하다고 생각한다.

## 컴포넌트 최적화

부모 컴포넌트가 리렌더링되면 자식 컴포넌트는 자신의 변화와 상관없이 무조건 리렌더링된다. 이렇게 자식 컴포넌트가 무조건적으로 리렌더링되기 보다는, 해당 컴포넌트가 넘겨 받는 `props` 값이 변경될 때만 리렌더링되도록 하여 렌더링 비용을 최적화를 할 수 있다.

- shouldComponentUpdate: 클래스 컴포넌트라면 `shouldComponentUpdate` 메서드를 구현하여 해당 함수가 `false` 를 반환할때만 리렌더링되도록 구현할 수 있다.
- React.memo: 메모이제이션을 위한 고차 컴포넌트로, `props` 가 변경될 때만 리렌더링되도록 한다.
- useMemo: 의존성 배열이 변경되는 경우에만 값(혹은 컴포넌트)를 재생성한다.

## 함수 최적화

- useCallback: 의존성 배열이 변경되는 경우에만 함수 자체를 재생성한다.
