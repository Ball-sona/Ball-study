# JWT

**JWT(JSON Web Token)** 란 인증에 필요한 정보들을 암호화시킨 JSON 토큰을 의미한다.

JWT 기반 인증에 대해 알아보기 전에 기존의 클라이언트 인증 방식에 대해 간단히 알아보자.

## 클라이언트 인증 방식

서버가 클라이언트 인증을 확인하는 방식은 대표적으로 쿠키, 세션, 토큰 3가지 방식이 있다.

### Cookie 인증

- 쿠키는 key-value 형식의 문자열 형태로 구성되어 있다.
- 클라이언트가 어떤 웹사이트에 방문할 경우 그 사이트의 서버를 통해 **클라이언트의 브라우저에 설치되는 작은 기록 정보 파일**이다.

- 인증 방식

  <img width="639" alt="스크린샷 2023-02-13 17 38 42" src="https://user-images.githubusercontent.com/67703882/218409938-66141c3f-6e49-4283-b6f6-a2c5c6b487ac.png">

  - 브라우저(클라이언트)가 서버에 요청(접속)을 보낸다.
  - 서버는 클라이언트의 요청에 대한 응답에 클라이언트 측에 저장하고 싶은 정보를 응답 헤더의 Set-Cookie에 담는다.
  - 이후 해당 클라이언트는 요청을 보낼 때마다 매번 저장한 쿠키를 요청 헤더의 Cookie에 담아 보낸다.
  - 서버는 Cookie에 담긴 정보를 바탕으로 해당 요청의 클라이언트가 누군지 식별하거나 정보를 바탕으로 추천 광고를 띄우는 등 이를 활용한다.

- 단점

  - 보안에 취약하다.
  - 용량 제한으로 많은 정보를 담을 수 없다.
  - 웹 브라우저마다 쿠키 지원 형태가 달라서 브라우저 간 공유가 불가능
  - 네트워크 부하에 악영향

### Session 인증

- 쿠키의 보안적인 이슈을 고려하여, 세션은 비밀번호 등 클라이언트의 민감한 인증 정보를 브라우저가 아닌 **서버 측에 저장하고 관리**한다.

- 인증 방식

  <img width="549" alt="스크린샷 2023-02-13 17 45 06" src="https://user-images.githubusercontent.com/67703882/218411272-4f186a32-9ab2-4f14-98f7-39a3d4224c8c.png">

  - 클라이언트가 서버에 접속 요청을 한다.
  - 서버는 클라이언트 별로 고유한 Session id를 생성한 후 이를 가지고 세션을 서버 측에 저장 후 클라이언트에 응답한다.
  - 클라이언트는 세션 쿠키를 저장했다가 동일한 서버에 요청할 때 Session id을 쿠키에 담아 전송한다.
  - 서버는 클라이언트가 보낸 Session id와 서버에서 관리하고 있는 Session id를 비교하여 인증을 수행한다.

- 단점

  - 쿠키가 외부에 노출되더라도 Session id 자체는 유의미한 개인 정보를 담고 있지 않으므로 쿠키에 비해 보안이 높다. 그러나 해커가 Session id 자체를 탈취하여 클라이언트인 척 위장할 수 있다.
  - 서버에서 세션 저장소를 사용하므로 요청이 많아지면 서버에 부하가 심해진다.

### Token 인증

- 클라이언트가 서버에 접속하면 서버는 해당 클라이언트에게 인증되었다는 의미로 **토큰을 부여**한다.

- 해당 토큰은 유일하고, 토큰을 발급받은 클라이언트는 동일한 서버에 요청을 보낼 때 요청 헤더에 토큰을 심어서 보낸다. 서버는 클라이언트로부터 전달받은 토큰과 서버에서 제공한 토큰과의 일치 여부를 체크하여 인증 과정을 처리한다.

- 인증 방식

  <img width="551" alt="스크린샷 2023-02-13 17 54 45" src="https://user-images.githubusercontent.com/67703882/218413398-3acdd8f4-a73a-4a81-89cc-c15b973d1b04.png">

  - 사용자가 아이디와 비밀번호로 로그인을 한다.
  - 서버는 클라이언트에게 유일한 토큰을 발급한다.
  - 클라이언트는 서버 측에서 전달 받은 토큰을 쿠키나 스토리지에 저장해두고, 서버에 요청할 때마다 해당 토큰을 HTTP 요청 헤더에 포함시켜 전달한다.
  - 서버는 전달받은 토큰을 검증하고 요청에 응답한다.

- 장점

  - 기존 세션 기반의 인증은 서버에 세션 정보를 저장하므로 이를 조회하는 과정에서 많은 오버헤드가 발생할 수 있다. 반면 토큰은 세션과 달리 클라이언트에 저장되기 때문에 서버의 부담을 덜 수 있다.
  - 쿠키와 세션을 사용할 수 없는 앱에서 서버와 통신 및 인증할 때 많이 사용된다.

- 단점

  - 쿠키/세션에 비해 토큰 자체의 데이터 길이가 길어서 인증 요청이 많아지면 네트워크 부하가 심해질 수 있다.
  - payload 자체는 암호화되지 않기 때문에 중요한 정보는 담을 수 없다.
  - 토큰을 탈취당하면 대처하기 어렵다. (사용 기간 제한을 설정하는 식으로 극복한다.)

## JWT(JSON Web Token)

- JWT(JSON Web Token)

  - 인증에 필요한 정보들을 암호화시킨 JSON 토큰
  - JSON 데이터를 Base64 URL-safe Encode를 통해 인코딩하여 직렬화한 것
  - 토큰 내부에는 위변조 방지를 위해 개인키를 통한 전자서명도 들어있다.
  - 비대칭 암호화 알고리즘을 사용하므로 암호화(전자서명)을 위한 키와 복호화(검증)을 위한 키가 다르다.

- JWT Token(Access Token) 을 HTTP 헤더에 실어 서버가 클라이언트를 식별하는 방식이다.

- JWT 구조

  <img width="607" alt="스크린샷 2023-02-13 19 55 29" src="https://user-images.githubusercontent.com/67703882/218439560-6762bf25-65a3-42c9-bf35-c19bc9adb228.png">

  - Header : 서명 암호화 알고리즘(HMAC SHA256 등) 과 토큰 유형이 담겨있다.
  - Payload : 토큰에서 사용할 정보의 조각들인 Claim(key-value)이 담겨있다. 실제 사용될 정보에 대한 내용이다.
  - Signature : (헤더+페이로드) 와 서버가 갖고있는 유일한 key 값을 합친 것을 헤더에서 정의한 알고리즘 방식(alg)으로 암호화한다.

- 인증 방식

  <img width="638" alt="스크린샷 2023-02-13 20 00 31" src="https://user-images.githubusercontent.com/67703882/218440633-0e9804a6-5f47-4064-bf7a-e31651ce0d3d.png">

  - 클라이언트가 아이디와 비밀번호를 입력하여 서버에 로그인 인증을 요청한다.
  - 서버에서 클라이언트로부터 인증 요청을 받으면 Header, Payload, Signature를 정의한다. 이들을 각각 Base64로 한번 더 암호화하여 JWT를 생성하고 이를 쿠키에 담아 클라이언트에게 발급한다.
  - 클라이언트는 서버로부터 받은 JWT를 로컬 스토리지에 저장한다. 이후 로그인 등 API를 서버에 요청할 때 Authorization Header에 Access Token을 담아서 보낸다.
  - 서버는 클라이언트가 헤더에 담아 보낸 JWT가 서버에서 발행한 토큰인지 일치 여부를 확인하고, 일치한다면 인증을 통과시켜준다.
  - 클라이언트가 서버에 요청을 했는데 만약 Access Token의 시간이 만료되어있다면 클라이언트는 리프래시 토큰을 이용해서 서버로부터 새로운 Access Token을 발급 받는다.

- 장점

  - 인증을 위한 별도의 저장소가 필요없다.
  - Header와 Payload를 가지고 Signature를 생성하므로 데이터 위변조를 막을 수 있다.
  - 토큰 기반으로 다른 로그인 시스템에 접근 및 권한 공유가 가능하다.
  - 클라이언트 인증 정보를 저장하는 세션과 다르게, 서버는 stateless 되어 서버 확장성이 비교적 좋다.

- 단점

  - 토큰 payload에 3종류의 claim을 저장하기 때문에 정보가 많아질수록 토큰의 길이가 늘어나 네트워크 부하를 줄 수 있다.

  - payload 자체는 암호화된 것이 아니라 base64로 인코딩된 것이기 때문에 중간에 payload를 탈취하여 디코딩하면 데이터를 볼 수 있으므로, payload에 중요 데이터를 넣으면 안된다.

  - 토큰을 클라이언트 측에서 관리하고 저장하므로 토큰 자체를 탈취당하면 대처하기 어렵다.

## Node.js에서 JWT 토큰 다루기

jsonwebtoken 설치하기

```
yarn add -D jsonwebtoken
```

`jwt.sign()` 를 이용해 JWT 토큰을 생성하자. 먼저 함수 인자를 살펴보면 다음과 같다.

```javascript
jwt.sign(payload, secretOrPrivateKey, [options, callback]);
```

```
import jwt from 'jsonwebtoken'

jwt.sign()
```

Private clain에 key가 test, value가 test인 데이터를 입력하였고

Signature 자리엔 secretKey라는 데이터를 입력하였다.

Public Claim 자리엔 subject(토큰제목)와 expiresIn(만료시간), issuer(발급자) 데이터를 입력하였다.

## Access Token, Refresh Token

- Access Token
  - 클라이언트가 갖고 있는 실제로 유저 정보가 담긴 토큰
- Refresh Token
  - 새로운 Access Token을 발급해주기 위해 사용하는 토큰으로, 짧은 수명을 가지는 Access Token에게 새로운 토큰을 발급해주기 위해 사용
  - 유효 기간이 비교적 길다.
  - 보통 데이터베이스에 유저 정보와 같이 기록

## Authorization

서버로 요청을 보낼때 보통 요청 헤더에 `Authorization: <type> <credentials>` 를 담아서 보낸다. 여기서 `type` 에는 여러 종류가 있다.

### Basic

- 사용자 아이디와 비밀번호를 Base64로 인코딩한 값을 토큰으로 사용한다. (RFC 7617)
- Basic 토큰 값이 노출되면 아이디, 비밀번호 값이 노출되는 것이기 때문에 보안에 취약하다.

### Bearer

- JWT(RFC 7519) 같은 OAuth 토큰을 사용한다.
- Basic 방식과 달리 토큰에 아이디, 비밀번호 값을 넣지 않는다.
- 로그인 시 토큰을 부여받고 이후 요청할 때 요청 헤더에 토큰을 실어서 보낸다.

- '보호된 리소스에 대한 접근 권한을 부여받기 위해 제시하는 유일한 작업이 토큰을 전달하는 것 뿐'
